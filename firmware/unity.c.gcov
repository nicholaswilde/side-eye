        -:    0:Source:.pio/libdeps/native/Unity/src/unity.c
        -:    0:Graph:/home/nicholas/git/nicholaswilde/side-eye/firmware/.pio/build/native/lib780/Unity/unity.gcno
        -:    0:Data:/home/nicholas/git/nicholaswilde/side-eye/firmware/.pio/build/native/lib780/Unity/unity.gcda
        -:    0:Runs:2
        -:    1:/* =========================================================================
        -:    2:    Unity - A Test Framework for C
        -:    3:    ThrowTheSwitch.org
        -:    4:    Copyright (c) 2007-25 Mike Karlesky, Mark VanderVoord, & Greg Williams
        -:    5:    SPDX-License-Identifier: MIT
        -:    6:========================================================================= */
        -:    7:
        -:    8:#include "unity.h"
        -:    9:
        -:   10:#ifndef UNITY_PROGMEM
        -:   11:#define UNITY_PROGMEM
        -:   12:#endif
        -:   13:
        -:   14:/* If omitted from header, declare overrideable prototypes here so they're ready for use */
        -:   15:#ifdef UNITY_OMIT_OUTPUT_CHAR_HEADER_DECLARATION
        -:   16:void UNITY_OUTPUT_CHAR(int);
        -:   17:#endif
        -:   18:
        -:   19:/* Helpful macros for us to use here in Assert functions */
        -:   20:#define UNITY_FAIL_AND_BAIL         do { Unity.CurrentTestFailed  = 1; UNITY_OUTPUT_FLUSH(); TEST_ABORT(); } while (0)
        -:   21:#define UNITY_IGNORE_AND_BAIL       do { Unity.CurrentTestIgnored = 1; UNITY_OUTPUT_FLUSH(); TEST_ABORT(); } while (0)
        -:   22:#define RETURN_IF_FAIL_OR_IGNORE    do { if (Unity.CurrentTestFailed || Unity.CurrentTestIgnored) { TEST_ABORT(); } } while (0)
        -:   23:
        -:   24:struct UNITY_STORAGE_T Unity;
        -:   25:
        -:   26:#ifdef UNITY_OUTPUT_COLOR
        -:   27:const char UNITY_PROGMEM UnityStrOk[]                            = "\033[42mOK\033[0m";
        -:   28:const char UNITY_PROGMEM UnityStrPass[]                          = "\033[42mPASS\033[0m";
        -:   29:const char UNITY_PROGMEM UnityStrFail[]                          = "\033[41mFAIL\033[0m";
        -:   30:const char UNITY_PROGMEM UnityStrIgnore[]                        = "\033[43mIGNORE\033[0m";
        -:   31:#else
        -:   32:const char UNITY_PROGMEM UnityStrOk[]                            = "OK";
        -:   33:const char UNITY_PROGMEM UnityStrPass[]                          = "PASS";
        -:   34:const char UNITY_PROGMEM UnityStrFail[]                          = "FAIL";
        -:   35:const char UNITY_PROGMEM UnityStrIgnore[]                        = "IGNORE";
        -:   36:#endif
        -:   37:static const char UNITY_PROGMEM UnityStrNull[]                   = "NULL";
        -:   38:static const char UNITY_PROGMEM UnityStrSpacer[]                 = ". ";
        -:   39:static const char UNITY_PROGMEM UnityStrExpected[]               = " Expected ";
        -:   40:static const char UNITY_PROGMEM UnityStrWas[]                    = " Was ";
        -:   41:static const char UNITY_PROGMEM UnityStrGt[]                     = " to be greater than ";
        -:   42:static const char UNITY_PROGMEM UnityStrLt[]                     = " to be less than ";
        -:   43:static const char UNITY_PROGMEM UnityStrOrEqual[]                = "or equal to ";
        -:   44:static const char UNITY_PROGMEM UnityStrNotEqual[]               = " to be not equal to ";
        -:   45:static const char UNITY_PROGMEM UnityStrElement[]                = " Element ";
        -:   46:static const char UNITY_PROGMEM UnityStrByte[]                   = " Byte ";
        -:   47:static const char UNITY_PROGMEM UnityStrMemory[]                 = " Memory Mismatch.";
        -:   48:static const char UNITY_PROGMEM UnityStrDelta[]                  = " Values Not Within Delta ";
        -:   49:static const char UNITY_PROGMEM UnityStrPointless[]              = " You Asked Me To Compare Nothing, Which Was Pointless.";
        -:   50:static const char UNITY_PROGMEM UnityStrNullPointerForExpected[] = " Expected pointer to be NULL";
        -:   51:static const char UNITY_PROGMEM UnityStrNullPointerForActual[]   = " Actual pointer was NULL";
        -:   52:#ifndef UNITY_EXCLUDE_FLOAT
        -:   53:static const char UNITY_PROGMEM UnityStrNot[]                    = "Not ";
        -:   54:static const char UNITY_PROGMEM UnityStrInf[]                    = "Infinity";
        -:   55:static const char UNITY_PROGMEM UnityStrNegInf[]                 = "Negative Infinity";
        -:   56:static const char UNITY_PROGMEM UnityStrNaN[]                    = "NaN";
        -:   57:static const char UNITY_PROGMEM UnityStrDet[]                    = "Determinate";
        -:   58:static const char UNITY_PROGMEM UnityStrInvalidFloatTrait[]      = "Invalid Float Trait";
        -:   59:#endif
        -:   60:const char UNITY_PROGMEM UnityStrErrShorthand[]                  = "Unity Shorthand Support Disabled";
        -:   61:const char UNITY_PROGMEM UnityStrErrFloat[]                      = "Unity Floating Point Disabled";
        -:   62:const char UNITY_PROGMEM UnityStrErrDouble[]                     = "Unity Double Precision Disabled";
        -:   63:const char UNITY_PROGMEM UnityStrErr64[]                         = "Unity 64-bit Support Disabled";
        -:   64:static const char UNITY_PROGMEM UnityStrBreaker[]                = "-----------------------";
        -:   65:static const char UNITY_PROGMEM UnityStrResultsTests[]           = " Tests ";
        -:   66:static const char UNITY_PROGMEM UnityStrResultsFailures[]        = " Failures ";
        -:   67:static const char UNITY_PROGMEM UnityStrResultsIgnored[]         = " Ignored ";
        -:   68:#ifndef UNITY_EXCLUDE_DETAILS
        -:   69:static const char UNITY_PROGMEM UnityStrDetail1Name[]            = UNITY_DETAIL1_NAME " ";
        -:   70:static const char UNITY_PROGMEM UnityStrDetail2Name[]            = " " UNITY_DETAIL2_NAME " ";
        -:   71:#endif
        -:   72:/*-----------------------------------------------
        -:   73: * Pretty Printers & Test Result Output Handlers
        -:   74: *-----------------------------------------------*/
        -:   75:
        -:   76:/*-----------------------------------------------*/
        -:   77:/* Local helper function to print characters. */
      252:   78:static void UnityPrintChar(const char* pch)
        -:   79:{
        -:   80:    /* printable characters plus CR & LF are printed */
      252:   81:    if ((*pch <= 126) && (*pch >= 32))
        -:   82:    {
      252:   83:        UNITY_OUTPUT_CHAR(*pch);
        -:   84:    }
        -:   85:    /* write escaped carriage returns */
    #####:   86:    else if (*pch == 13)
        -:   87:    {
    #####:   88:        UNITY_OUTPUT_CHAR('\\');
    #####:   89:        UNITY_OUTPUT_CHAR('r');
        -:   90:    }
        -:   91:    /* write escaped line feeds */
    #####:   92:    else if (*pch == 10)
        -:   93:    {
    #####:   94:        UNITY_OUTPUT_CHAR('\\');
    #####:   95:        UNITY_OUTPUT_CHAR('n');
        -:   96:    }
        -:   97:    /* unprintable characters are shown as codes */
        -:   98:    else
        -:   99:    {
    #####:  100:        UNITY_OUTPUT_CHAR('\\');
    #####:  101:        UNITY_OUTPUT_CHAR('x');
    #####:  102:        UnityPrintNumberHex((UNITY_UINT)*pch, 2);
        -:  103:    }
      252:  104:}
        -:  105:
        -:  106:/*-----------------------------------------------*/
        -:  107:/* Local helper function to print ANSI escape strings e.g. "\033[42m". */
        -:  108:#ifdef UNITY_OUTPUT_COLOR
        -:  109:static UNITY_UINT UnityPrintAnsiEscapeString(const char* string)
        -:  110:{
        -:  111:    const char* pch = string;
        -:  112:    UNITY_UINT count = 0;
        -:  113:
        -:  114:    while (*pch && (*pch != 'm'))
        -:  115:    {
        -:  116:        UNITY_OUTPUT_CHAR(*pch);
        -:  117:        pch++;
        -:  118:        count++;
        -:  119:    }
        -:  120:    UNITY_OUTPUT_CHAR('m');
        -:  121:    count++;
        -:  122:
        -:  123:    return count;
        -:  124:}
        -:  125:#endif
        -:  126:
        -:  127:/*-----------------------------------------------*/
       22:  128:void UnityPrint(const char* string)
        -:  129:{
       22:  130:    const char* pch = string;
        -:  131:
       22:  132:    if (pch != NULL)
        -:  133:    {
      274:  134:        while (*pch)
        -:  135:        {
        -:  136:#ifdef UNITY_OUTPUT_COLOR
        -:  137:            /* print ANSI escape code */
        -:  138:            if ((*pch == 27) && (*(pch + 1) == '['))
        -:  139:            {
        -:  140:                pch += UnityPrintAnsiEscapeString(pch);
        -:  141:                continue;
        -:  142:            }
        -:  143:#endif
      252:  144:            UnityPrintChar(pch);
      252:  145:            pch++;
        -:  146:        }
        -:  147:    }
       22:  148:}
        -:  149:/*-----------------------------------------------*/
    #####:  150:void UnityPrintLen(const char* string, const UNITY_UINT32 length)
        -:  151:{
    #####:  152:    const char* pch = string;
        -:  153:
    #####:  154:    if (pch != NULL)
        -:  155:    {
    #####:  156:        while (*pch && ((UNITY_UINT32)(pch - string) < length))
        -:  157:        {
        -:  158:            /* printable characters plus CR & LF are printed */
    #####:  159:            if ((*pch <= 126) && (*pch >= 32))
        -:  160:            {
    #####:  161:                UNITY_OUTPUT_CHAR(*pch);
        -:  162:            }
        -:  163:            /* write escaped carriage returns */
    #####:  164:            else if (*pch == 13)
        -:  165:            {
    #####:  166:                UNITY_OUTPUT_CHAR('\\');
    #####:  167:                UNITY_OUTPUT_CHAR('r');
        -:  168:            }
        -:  169:            /* write escaped line feeds */
    #####:  170:            else if (*pch == 10)
        -:  171:            {
    #####:  172:                UNITY_OUTPUT_CHAR('\\');
    #####:  173:                UNITY_OUTPUT_CHAR('n');
        -:  174:            }
        -:  175:            /* unprintable characters are shown as codes */
        -:  176:            else
        -:  177:            {
    #####:  178:                UNITY_OUTPUT_CHAR('\\');
    #####:  179:                UNITY_OUTPUT_CHAR('x');
    #####:  180:                UnityPrintNumberHex((UNITY_UINT)*pch, 2);
        -:  181:            }
    #####:  182:            pch++;
        -:  183:        }
        -:  184:    }
    #####:  185:}
        -:  186:
        -:  187:/*-----------------------------------------------*/
    #####:  188:void UnityPrintNumberByStyle(const UNITY_INT number, const UNITY_DISPLAY_STYLE_T style)
        -:  189:{
    #####:  190:    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -:  191:    {
    #####:  192:        if (style == UNITY_DISPLAY_STYLE_CHAR)
        -:  193:        {
        -:  194:            /* printable characters plus CR & LF are printed */
    #####:  195:            UNITY_OUTPUT_CHAR('\'');
    #####:  196:            if ((number <= 126) && (number >= 32))
        -:  197:            {
    #####:  198:                UNITY_OUTPUT_CHAR((int)number);
        -:  199:            }
        -:  200:            /* write escaped carriage returns */
    #####:  201:            else if (number == 13)
        -:  202:            {
    #####:  203:                UNITY_OUTPUT_CHAR('\\');
    #####:  204:                UNITY_OUTPUT_CHAR('r');
        -:  205:            }
        -:  206:            /* write escaped line feeds */
    #####:  207:            else if (number == 10)
        -:  208:            {
    #####:  209:                UNITY_OUTPUT_CHAR('\\');
    #####:  210:                UNITY_OUTPUT_CHAR('n');
        -:  211:            }
        -:  212:            /* unprintable characters are shown as codes */
        -:  213:            else
        -:  214:            {
    #####:  215:                UNITY_OUTPUT_CHAR('\\');
    #####:  216:                UNITY_OUTPUT_CHAR('x');
    #####:  217:                UnityPrintNumberHex((UNITY_UINT)number, 2);
        -:  218:            }
    #####:  219:            UNITY_OUTPUT_CHAR('\'');
        -:  220:        }
        -:  221:        else
        -:  222:        {
    #####:  223:            UnityPrintNumber(number);
        -:  224:        }
        -:  225:    }
    #####:  226:    else if ((style & UNITY_DISPLAY_RANGE_UINT) == UNITY_DISPLAY_RANGE_UINT)
        -:  227:    {
    #####:  228:        UnityPrintNumberUnsigned((UNITY_UINT)number);
        -:  229:    }
        -:  230:    else
        -:  231:    {
    #####:  232:        UNITY_OUTPUT_CHAR('0');
    #####:  233:        UNITY_OUTPUT_CHAR('x');
    #####:  234:        UnityPrintNumberHex((UNITY_UINT)number, (char)((style & 0xF) * 2));
        -:  235:    }
    #####:  236:}
        -:  237:
        -:  238:/*-----------------------------------------------*/
       10:  239:void UnityPrintNumber(const UNITY_INT number_to_print)
        -:  240:{
       10:  241:    UNITY_UINT number = (UNITY_UINT)number_to_print;
        -:  242:
       10:  243:    if (number_to_print < 0)
        -:  244:    {
        -:  245:        /* A negative number, including MIN negative */
    #####:  246:        UNITY_OUTPUT_CHAR('-');
    #####:  247:        number = (~number) + 1;
        -:  248:    }
       10:  249:    UnityPrintNumberUnsigned(number);
       10:  250:}
        -:  251:
        -:  252:/*-----------------------------------------------
        -:  253: * basically do an itoa using as little ram as possible */
       10:  254:void UnityPrintNumberUnsigned(const UNITY_UINT number)
        -:  255:{
       10:  256:    UNITY_UINT divisor = 1;
        -:  257:
        -:  258:    /* figure out initial divisor */
       14:  259:    while (number / divisor > 9)
        -:  260:    {
        4:  261:        divisor *= 10;
        -:  262:    }
        -:  263:
        -:  264:    /* now mod and print, then divide divisor */
        -:  265:    do
        -:  266:    {
       14:  267:        UNITY_OUTPUT_CHAR((char)('0' + (number / divisor % 10)));
       14:  268:        divisor /= 10;
       14:  269:    } while (divisor > 0);
       10:  270:}
        -:  271:
        -:  272:/*-----------------------------------------------*/
    #####:  273:void UnityPrintNumberHex(const UNITY_UINT number, const char nibbles_to_print)
        -:  274:{
        -:  275:    int nibble;
    #####:  276:    char nibbles = nibbles_to_print;
        -:  277:
    #####:  278:    if ((unsigned)nibbles > UNITY_MAX_NIBBLES)
        -:  279:    {
    #####:  280:        nibbles = UNITY_MAX_NIBBLES;
        -:  281:    }
        -:  282:
    #####:  283:    while (nibbles > 0)
        -:  284:    {
    #####:  285:        nibbles--;
    #####:  286:        nibble = (int)(number >> (nibbles * 4)) & 0x0F;
    #####:  287:        if (nibble <= 9)
        -:  288:        {
    #####:  289:            UNITY_OUTPUT_CHAR((char)('0' + nibble));
        -:  290:        }
        -:  291:        else
        -:  292:        {
    #####:  293:            UNITY_OUTPUT_CHAR((char)('A' - 10 + nibble));
        -:  294:        }
        -:  295:    }
    #####:  296:}
        -:  297:
        -:  298:/*-----------------------------------------------*/
    #####:  299:void UnityPrintMask(const UNITY_UINT mask, const UNITY_UINT number)
        -:  300:{
    #####:  301:    UNITY_UINT current_bit = (UNITY_UINT)1 << (UNITY_INT_WIDTH - 1);
        -:  302:    UNITY_INT32 i;
        -:  303:
    #####:  304:    for (i = 0; i < UNITY_INT_WIDTH; i++)
        -:  305:    {
    #####:  306:        if (current_bit & mask)
        -:  307:        {
    #####:  308:            if (current_bit & number)
        -:  309:            {
    #####:  310:                UNITY_OUTPUT_CHAR('1');
        -:  311:            }
        -:  312:            else
        -:  313:            {
    #####:  314:                UNITY_OUTPUT_CHAR('0');
        -:  315:            }
        -:  316:        }
        -:  317:        else
        -:  318:        {
    #####:  319:            UNITY_OUTPUT_CHAR('X');
        -:  320:        }
    #####:  321:        current_bit = current_bit >> 1;
        -:  322:    }
    #####:  323:}
        -:  324:
        -:  325:/*-----------------------------------------------*/
        -:  326:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -:  327:/*
        -:  328: * This function prints a floating-point value in a format similar to
        -:  329: * printf("%.7g") on a single-precision machine or printf("%.9g") on a
        -:  330: * double-precision machine.  The 7th digit won't always be totally correct
        -:  331: * in single-precision operation (for that level of accuracy, a more
        -:  332: * complicated algorithm would be needed).
        -:  333: */
    #####:  334:void UnityPrintFloat(const UNITY_DOUBLE input_number)
        -:  335:{
        -:  336:#ifdef UNITY_INCLUDE_DOUBLE
        -:  337:    static const int sig_digits = 9;
        -:  338:    static const UNITY_INT32 min_scaled = 100000000;
        -:  339:    static const UNITY_INT32 max_scaled = 1000000000;
        -:  340:#else
        -:  341:    static const int sig_digits = 7;
        -:  342:    static const UNITY_INT32 min_scaled = 1000000;
        -:  343:    static const UNITY_INT32 max_scaled = 10000000;
        -:  344:#endif
        -:  345:
    #####:  346:    UNITY_DOUBLE number = input_number;
        -:  347:
        -:  348:    /* print minus sign (does not handle negative zero) */
    #####:  349:    if (number < 0.0f)
        -:  350:    {
    #####:  351:        UNITY_OUTPUT_CHAR('-');
    #####:  352:        number = -number;
        -:  353:    }
        -:  354:
        -:  355:    /* handle zero, NaN, and +/- infinity */
    #####:  356:    if (number == 0.0f)
        -:  357:    {
    #####:  358:        UnityPrint("0");
        -:  359:    }
    #####:  360:    else if (UNITY_IS_NAN(number))
        -:  361:    {
    #####:  362:        UnityPrint("nan");
        -:  363:    }
    #####:  364:    else if (UNITY_IS_INF(number))
        -:  365:    {
    #####:  366:        UnityPrint("inf");
        -:  367:    }
        -:  368:    else
        -:  369:    {
    #####:  370:        UNITY_INT32 n_int = 0;
        -:  371:        UNITY_INT32 n;
    #####:  372:        int         exponent = 0;
        -:  373:        int         decimals;
        -:  374:        int         digits;
    #####:  375:        char        buf[16] = {0};
        -:  376:
        -:  377:        /*
        -:  378:         * Scale up or down by powers of 10.  To minimize rounding error,
        -:  379:         * start with a factor/divisor of 10^10, which is the largest
        -:  380:         * power of 10 that can be represented exactly.  Finally, compute
        -:  381:         * (exactly) the remaining power of 10 and perform one more
        -:  382:         * multiplication or division.
        -:  383:         */
    #####:  384:        if (number < 1.0f)
        -:  385:        {
    #####:  386:            UNITY_DOUBLE factor = 1.0f;
        -:  387:
    #####:  388:            while (number < (UNITY_DOUBLE)max_scaled / 1e10f)  { number *= 1e10f; exponent -= 10; }
    #####:  389:            while (number * factor < (UNITY_DOUBLE)min_scaled) { factor *= 10.0f; exponent--; }
        -:  390:
    #####:  391:            number *= factor;
        -:  392:        }
    #####:  393:        else if (number > (UNITY_DOUBLE)max_scaled)
        -:  394:        {
    #####:  395:            UNITY_DOUBLE divisor = 1.0f;
        -:  396:
    #####:  397:            while (number > (UNITY_DOUBLE)min_scaled * 1e10f)   { number  /= 1e10f; exponent += 10; }
    #####:  398:            while (number / divisor > (UNITY_DOUBLE)max_scaled) { divisor *= 10.0f; exponent++; }
        -:  399:
    #####:  400:            number /= divisor;
        -:  401:        }
        -:  402:        else
        -:  403:        {
        -:  404:            /*
        -:  405:             * In this range, we can split off the integer part before
        -:  406:             * doing any multiplications.  This reduces rounding error by
        -:  407:             * freeing up significant bits in the fractional part.
        -:  408:             */
    #####:  409:            UNITY_DOUBLE factor = 1.0f;
    #####:  410:            n_int = (UNITY_INT32)number;
    #####:  411:            number -= (UNITY_DOUBLE)n_int;
        -:  412:
    #####:  413:            while (n_int < min_scaled) { n_int *= 10; factor *= 10.0f; exponent--; }
        -:  414:
    #####:  415:            number *= factor;
        -:  416:        }
        -:  417:
        -:  418:        /* round to nearest integer */
    #####:  419:        n = ((UNITY_INT32)(number + number) + 1) / 2;
        -:  420:
        -:  421:#ifndef UNITY_ROUND_TIES_AWAY_FROM_ZERO
        -:  422:        /* round to even if exactly between two integers */
    #####:  423:        if ((n & 1) && (((UNITY_DOUBLE)n - number) == 0.5f))
    #####:  424:            n--;
        -:  425:#endif
        -:  426:
    #####:  427:        n += n_int;
        -:  428:
    #####:  429:        if (n >= max_scaled)
        -:  430:        {
    #####:  431:            n = min_scaled;
    #####:  432:            exponent++;
        -:  433:        }
        -:  434:
        -:  435:        /* determine where to place decimal point */
    #####:  436:        decimals = ((exponent <= 0) && (exponent >= -(sig_digits + 3))) ? (-exponent) : (sig_digits - 1);
    #####:  437:        exponent += decimals;
        -:  438:
        -:  439:        /* truncate trailing zeroes after decimal point */
    #####:  440:        while ((decimals > 0) && ((n % 10) == 0))
        -:  441:        {
    #####:  442:            n /= 10;
    #####:  443:            decimals--;
        -:  444:        }
        -:  445:
        -:  446:        /* build up buffer in reverse order */
    #####:  447:        digits = 0;
    #####:  448:        while ((n != 0) || (digits <= decimals))
        -:  449:        {
    #####:  450:            buf[digits++] = (char)('0' + n % 10);
    #####:  451:            n /= 10;
        -:  452:        }
        -:  453:
        -:  454:        /* print out buffer (backwards) */
    #####:  455:        while (digits > 0)
        -:  456:        {
    #####:  457:            if (digits == decimals)
        -:  458:            {
    #####:  459:                UNITY_OUTPUT_CHAR('.');
        -:  460:            }
    #####:  461:            UNITY_OUTPUT_CHAR(buf[--digits]);
        -:  462:        }
        -:  463:
        -:  464:        /* print exponent if needed */
    #####:  465:        if (exponent != 0)
        -:  466:        {
    #####:  467:            UNITY_OUTPUT_CHAR('e');
        -:  468:
    #####:  469:            if (exponent < 0)
        -:  470:            {
    #####:  471:                UNITY_OUTPUT_CHAR('-');
    #####:  472:                exponent = -exponent;
        -:  473:            }
        -:  474:            else
        -:  475:            {
    #####:  476:                UNITY_OUTPUT_CHAR('+');
        -:  477:            }
        -:  478:
    #####:  479:            digits = 0;
    #####:  480:            while ((exponent != 0) || (digits < 2))
        -:  481:            {
    #####:  482:                buf[digits++] = (char)('0' + exponent % 10);
    #####:  483:                exponent /= 10;
        -:  484:            }
    #####:  485:            while (digits > 0)
        -:  486:            {
    #####:  487:                UNITY_OUTPUT_CHAR(buf[--digits]);
        -:  488:            }
        -:  489:        }
        -:  490:    }
    #####:  491:}
        -:  492:#endif /* ! UNITY_EXCLUDE_FLOAT_PRINT */
        -:  493:
        -:  494:/*-----------------------------------------------*/
        4:  495:static void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)
        -:  496:{
        -:  497:#ifdef UNITY_OUTPUT_FOR_ECLIPSE
        -:  498:    UNITY_OUTPUT_CHAR('(');
        -:  499:    UnityPrint(file);
        -:  500:    UNITY_OUTPUT_CHAR(':');
        -:  501:    UnityPrintNumber((UNITY_INT)line);
        -:  502:    UNITY_OUTPUT_CHAR(')');
        -:  503:    UNITY_OUTPUT_CHAR(' ');
        -:  504:    UnityPrint(Unity.CurrentTestName);
        -:  505:    UNITY_OUTPUT_CHAR(':');
        -:  506:#else
        -:  507:#ifdef UNITY_OUTPUT_FOR_IAR_WORKBENCH
        -:  508:    UnityPrint("<SRCREF line=");
        -:  509:    UnityPrintNumber((UNITY_INT)line);
        -:  510:    UnityPrint(" file=\"");
        -:  511:    UnityPrint(file);
        -:  512:    UNITY_OUTPUT_CHAR('"');
        -:  513:    UNITY_OUTPUT_CHAR('>');
        -:  514:    UnityPrint(Unity.CurrentTestName);
        -:  515:    UnityPrint("</SRCREF> ");
        -:  516:#else
        -:  517:#ifdef UNITY_OUTPUT_FOR_QT_CREATOR
        -:  518:    UnityPrint("file://");
        -:  519:    UnityPrint(file);
        -:  520:    UNITY_OUTPUT_CHAR(':');
        -:  521:    UnityPrintNumber((UNITY_INT)line);
        -:  522:    UNITY_OUTPUT_CHAR(' ');
        -:  523:    UnityPrint(Unity.CurrentTestName);
        -:  524:    UNITY_OUTPUT_CHAR(':');
        -:  525:#else
        4:  526:    UnityPrint(file);
        4:  527:    UNITY_OUTPUT_CHAR(':');
        4:  528:    UnityPrintNumber((UNITY_INT)line);
        4:  529:    UNITY_OUTPUT_CHAR(':');
        4:  530:    UnityPrint(Unity.CurrentTestName);
        4:  531:    UNITY_OUTPUT_CHAR(':');
        -:  532:#endif
        -:  533:#endif
        -:  534:#endif
        4:  535:}
        -:  536:
        -:  537:/*-----------------------------------------------*/
    #####:  538:static void UnityTestResultsFailBegin(const UNITY_LINE_TYPE line)
        -:  539:{
    #####:  540:    UnityTestResultsBegin(Unity.TestFile, line);
    #####:  541:    UnityPrint(UnityStrFail);
    #####:  542:    UNITY_OUTPUT_CHAR(':');
    #####:  543:}
        -:  544:
        -:  545:/*-----------------------------------------------*/
        4:  546:void UnityConcludeTest(void)
        -:  547:{
        4:  548:    if (Unity.CurrentTestIgnored)
        -:  549:    {
    #####:  550:        Unity.TestIgnores++;
        -:  551:    }
        4:  552:    else if (!Unity.CurrentTestFailed)
        -:  553:    {
        4:  554:        UnityTestResultsBegin(Unity.TestFile, Unity.CurrentTestLineNumber);
        4:  555:        UnityPrint(UnityStrPass);
        -:  556:    }
        -:  557:    else
        -:  558:    {
    #####:  559:        Unity.TestFailures++;
        -:  560:    }
        -:  561:
        4:  562:    Unity.CurrentTestFailed = 0;
        4:  563:    Unity.CurrentTestIgnored = 0;
        -:  564:    UNITY_PRINT_EXEC_TIME();
        4:  565:    UNITY_PRINT_EOL();
        4:  566:    UNITY_FLUSH_CALL();
        4:  567:}
        -:  568:
        -:  569:/*-----------------------------------------------*/
    #####:  570:static void UnityAddMsgIfSpecified(const char* msg)
        -:  571:{
        -:  572:#ifdef UNITY_PRINT_TEST_CONTEXT
        -:  573:    UnityPrint(UnityStrSpacer);
        -:  574:    UNITY_PRINT_TEST_CONTEXT();
        -:  575:#endif
        -:  576:#ifndef UNITY_EXCLUDE_DETAILS
    #####:  577:    if (Unity.CurrentDetail1)
        -:  578:    {
    #####:  579:        UnityPrint(UnityStrSpacer);
    #####:  580:        UnityPrint(UnityStrDetail1Name);
    #####:  581:        UnityPrint(Unity.CurrentDetail1);
    #####:  582:        if (Unity.CurrentDetail2)
        -:  583:        {
    #####:  584:            UnityPrint(UnityStrDetail2Name);
    #####:  585:            UnityPrint(Unity.CurrentDetail2);
        -:  586:        }
        -:  587:    }
        -:  588:#endif
    #####:  589:    if (msg)
        -:  590:    {
    #####:  591:        UnityPrint(UnityStrSpacer);
    #####:  592:        UnityPrint(msg);
        -:  593:    }
    #####:  594:}
        -:  595:
        -:  596:/*-----------------------------------------------*/
    #####:  597:static void UnityPrintExpectedAndActualStrings(const char* expected, const char* actual)
        -:  598:{
    #####:  599:    UnityPrint(UnityStrExpected);
    #####:  600:    if (expected != NULL)
        -:  601:    {
    #####:  602:        UNITY_OUTPUT_CHAR('\'');
    #####:  603:        UnityPrint(expected);
    #####:  604:        UNITY_OUTPUT_CHAR('\'');
        -:  605:    }
        -:  606:    else
        -:  607:    {
    #####:  608:        UnityPrint(UnityStrNull);
        -:  609:    }
    #####:  610:    UnityPrint(UnityStrWas);
    #####:  611:    if (actual != NULL)
        -:  612:    {
    #####:  613:        UNITY_OUTPUT_CHAR('\'');
    #####:  614:        UnityPrint(actual);
    #####:  615:        UNITY_OUTPUT_CHAR('\'');
        -:  616:    }
        -:  617:    else
        -:  618:    {
    #####:  619:        UnityPrint(UnityStrNull);
        -:  620:    }
    #####:  621:}
        -:  622:
        -:  623:/*-----------------------------------------------*/
    #####:  624:static void UnityPrintExpectedAndActualStringsLen(const char* expected,
        -:  625:                                                  const char* actual,
        -:  626:                                                  const UNITY_UINT32 length)
        -:  627:{
    #####:  628:    UnityPrint(UnityStrExpected);
    #####:  629:    if (expected != NULL)
        -:  630:    {
    #####:  631:        UNITY_OUTPUT_CHAR('\'');
    #####:  632:        UnityPrintLen(expected, length);
    #####:  633:        UNITY_OUTPUT_CHAR('\'');
        -:  634:    }
        -:  635:    else
        -:  636:    {
    #####:  637:        UnityPrint(UnityStrNull);
        -:  638:    }
    #####:  639:    UnityPrint(UnityStrWas);
    #####:  640:    if (actual != NULL)
        -:  641:    {
    #####:  642:        UNITY_OUTPUT_CHAR('\'');
    #####:  643:        UnityPrintLen(actual, length);
    #####:  644:        UNITY_OUTPUT_CHAR('\'');
        -:  645:    }
        -:  646:    else
        -:  647:    {
    #####:  648:        UnityPrint(UnityStrNull);
        -:  649:    }
    #####:  650:}
        -:  651:
        -:  652:/*-----------------------------------------------
        -:  653: * Assertion & Control Helpers
        -:  654: *-----------------------------------------------*/
        -:  655:
        -:  656:/*-----------------------------------------------*/
    #####:  657:static int UnityIsOneArrayNull(UNITY_INTERNAL_PTR expected,
        -:  658:                               UNITY_INTERNAL_PTR actual,
        -:  659:                               const UNITY_LINE_TYPE lineNumber,
        -:  660:                               const char* msg)
        -:  661:{
        -:  662:    /* Both are NULL or same pointer */
    #####:  663:    if (expected == actual) { return 0; }
        -:  664:
        -:  665:    /* print and return true if just expected is NULL */
    #####:  666:    if (expected == NULL)
        -:  667:    {
    #####:  668:        UnityTestResultsFailBegin(lineNumber);
    #####:  669:        UnityPrint(UnityStrNullPointerForExpected);
    #####:  670:        UnityAddMsgIfSpecified(msg);
    #####:  671:        return 1;
        -:  672:    }
        -:  673:
        -:  674:    /* print and return true if just actual is NULL */
    #####:  675:    if (actual == NULL)
        -:  676:    {
    #####:  677:        UnityTestResultsFailBegin(lineNumber);
    #####:  678:        UnityPrint(UnityStrNullPointerForActual);
    #####:  679:        UnityAddMsgIfSpecified(msg);
    #####:  680:        return 1;
        -:  681:    }
        -:  682:
    #####:  683:    return 0; /* return false if neither is NULL */
        -:  684:}
        -:  685:
        -:  686:/*-----------------------------------------------
        -:  687: * Assertion Functions
        -:  688: *-----------------------------------------------*/
        -:  689:
        -:  690:/*-----------------------------------------------*/
    #####:  691:void UnityAssertBits(const UNITY_INT mask,
        -:  692:                     const UNITY_INT expected,
        -:  693:                     const UNITY_INT actual,
        -:  694:                     const char* msg,
        -:  695:                     const UNITY_LINE_TYPE lineNumber)
        -:  696:{
    #####:  697:    RETURN_IF_FAIL_OR_IGNORE;
        -:  698:
    #####:  699:    if ((mask & expected) != (mask & actual))
        -:  700:    {
    #####:  701:        UnityTestResultsFailBegin(lineNumber);
    #####:  702:        UnityPrint(UnityStrExpected);
    #####:  703:        UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)expected);
    #####:  704:        UnityPrint(UnityStrWas);
    #####:  705:        UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)actual);
    #####:  706:        UnityAddMsgIfSpecified(msg);
    #####:  707:        UNITY_FAIL_AND_BAIL;
        -:  708:    }
    #####:  709:}
        -:  710:
        -:  711:/*-----------------------------------------------*/
       24:  712:void UnityAssertEqualNumber(const UNITY_INT expected,
        -:  713:                            const UNITY_INT actual,
        -:  714:                            const char* msg,
        -:  715:                            const UNITY_LINE_TYPE lineNumber,
        -:  716:                            const UNITY_DISPLAY_STYLE_T style)
        -:  717:{
      24*:  718:    RETURN_IF_FAIL_OR_IGNORE;
        -:  719:
       24:  720:    if (expected != actual)
        -:  721:    {
    #####:  722:        UnityTestResultsFailBegin(lineNumber);
    #####:  723:        UnityPrint(UnityStrExpected);
    #####:  724:        UnityPrintNumberByStyle(expected, style);
    #####:  725:        UnityPrint(UnityStrWas);
    #####:  726:        UnityPrintNumberByStyle(actual, style);
    #####:  727:        UnityAddMsgIfSpecified(msg);
    #####:  728:        UNITY_FAIL_AND_BAIL;
        -:  729:    }
       24:  730:}
        -:  731:
        -:  732:/*-----------------------------------------------*/
    #####:  733:void UnityAssertGreaterOrLessOrEqualNumber(const UNITY_INT threshold,
        -:  734:                                           const UNITY_INT actual,
        -:  735:                                           const UNITY_COMPARISON_T compare,
        -:  736:                                           const char *msg,
        -:  737:                                           const UNITY_LINE_TYPE lineNumber,
        -:  738:                                           const UNITY_DISPLAY_STYLE_T style)
        -:  739:{
    #####:  740:    int failed = 0;
    #####:  741:    RETURN_IF_FAIL_OR_IGNORE;
        -:  742:
    #####:  743:    if ((threshold == actual) && (compare & UNITY_EQUAL_TO)) { return; }
    #####:  744:    if ((threshold == actual))                               { failed = 1; }
        -:  745:
    #####:  746:    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -:  747:    {
    #####:  748:        if ((actual > threshold) && (compare & UNITY_SMALLER_THAN)) { failed = 1; }
    #####:  749:        if ((actual < threshold) && (compare & UNITY_GREATER_THAN)) { failed = 1; }
        -:  750:    }
        -:  751:    else /* UINT or HEX */
        -:  752:    {
    #####:  753:        if (((UNITY_UINT)actual > (UNITY_UINT)threshold) && (compare & UNITY_SMALLER_THAN)) { failed = 1; }
    #####:  754:        if (((UNITY_UINT)actual < (UNITY_UINT)threshold) && (compare & UNITY_GREATER_THAN)) { failed = 1; }
        -:  755:    }
        -:  756:
    #####:  757:    if (failed)
        -:  758:    {
    #####:  759:        UnityTestResultsFailBegin(lineNumber);
    #####:  760:        UnityPrint(UnityStrExpected);
    #####:  761:        UnityPrintNumberByStyle(actual, style);
    #####:  762:        if (compare & UNITY_GREATER_THAN) { UnityPrint(UnityStrGt);       }
    #####:  763:        if (compare & UNITY_SMALLER_THAN) { UnityPrint(UnityStrLt);       }
    #####:  764:        if (compare & UNITY_EQUAL_TO)     { UnityPrint(UnityStrOrEqual);  }
    #####:  765:        if (compare == UNITY_NOT_EQUAL)   { UnityPrint(UnityStrNotEqual); }
    #####:  766:        UnityPrintNumberByStyle(threshold, style);
    #####:  767:        UnityAddMsgIfSpecified(msg);
    #####:  768:        UNITY_FAIL_AND_BAIL;
        -:  769:    }
        -:  770:}
        -:  771:
        -:  772:#define UnityPrintPointlessAndBail()       \
        -:  773:do {                                       \
        -:  774:    UnityTestResultsFailBegin(lineNumber); \
        -:  775:    UnityPrint(UnityStrPointless);         \
        -:  776:    UnityAddMsgIfSpecified(msg);           \
        -:  777:    UNITY_FAIL_AND_BAIL;                   \
        -:  778:} while (0)
        -:  779:
        -:  780:/*-----------------------------------------------*/
    #####:  781:void UnityAssertEqualIntArray(UNITY_INTERNAL_PTR expected,
        -:  782:                              UNITY_INTERNAL_PTR actual,
        -:  783:                              const UNITY_UINT32 num_elements,
        -:  784:                              const char* msg,
        -:  785:                              const UNITY_LINE_TYPE lineNumber,
        -:  786:                              const UNITY_DISPLAY_STYLE_T style,
        -:  787:                              const UNITY_FLAGS_T flags)
        -:  788:{
    #####:  789:    UNITY_UINT32 elements  = num_elements;
    #####:  790:    unsigned int length    = style & 0xF;
    #####:  791:    unsigned int increment = 0;
        -:  792:
    #####:  793:    RETURN_IF_FAIL_OR_IGNORE;
        -:  794:
    #####:  795:    if (num_elements == 0)
        -:  796:    {
        -:  797:#ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY
        -:  798:        UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);
        -:  799:#else
    #####:  800:        UnityPrintPointlessAndBail();
        -:  801:#endif
        -:  802:    }
        -:  803:
    #####:  804:    if (expected == actual)
        -:  805:    {
    #####:  806:        return; /* Both are NULL or same pointer */
        -:  807:    }
        -:  808:
    #####:  809:    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))
        -:  810:    {
    #####:  811:        UNITY_FAIL_AND_BAIL;
        -:  812:    }
        -:  813:
    #####:  814:    while ((elements > 0) && (elements--))
        -:  815:    {
        -:  816:        UNITY_INT expect_val;
        -:  817:        UNITY_INT actual_val;
        -:  818:
    #####:  819:        switch (length)
        -:  820:        {
    #####:  821:            case 1:
    #####:  822:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)expected;
    #####:  823:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)actual;
    #####:  824:                if (style & (UNITY_DISPLAY_RANGE_UINT | UNITY_DISPLAY_RANGE_HEX))
        -:  825:                {
    #####:  826:                    expect_val &= 0x000000FF;
    #####:  827:                    actual_val &= 0x000000FF;
        -:  828:                }
    #####:  829:                increment  = sizeof(UNITY_INT8);
    #####:  830:                break;
        -:  831:
    #####:  832:            case 2:
    #####:  833:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)expected;
    #####:  834:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)actual;
    #####:  835:                if (style & (UNITY_DISPLAY_RANGE_UINT | UNITY_DISPLAY_RANGE_HEX))
        -:  836:                {
    #####:  837:                    expect_val &= 0x0000FFFF;
    #####:  838:                    actual_val &= 0x0000FFFF;
        -:  839:                }
    #####:  840:                increment  = sizeof(UNITY_INT16);
    #####:  841:                break;
        -:  842:
        -:  843:#ifdef UNITY_SUPPORT_64
    #####:  844:            case 8:
    #####:  845:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)expected;
    #####:  846:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)actual;
    #####:  847:                increment  = sizeof(UNITY_INT64);
    #####:  848:                break;
        -:  849:#endif
        -:  850:
    #####:  851:            default: /* default is length 4 bytes */
        -:  852:            case 4:
    #####:  853:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)expected;
    #####:  854:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)actual;
        -:  855:#ifdef UNITY_SUPPORT_64
    #####:  856:                if (style & (UNITY_DISPLAY_RANGE_UINT | UNITY_DISPLAY_RANGE_HEX))
        -:  857:                {
    #####:  858:                    expect_val &= 0x00000000FFFFFFFF;
    #####:  859:                    actual_val &= 0x00000000FFFFFFFF;
        -:  860:                }
        -:  861:#endif
    #####:  862:                increment  = sizeof(UNITY_INT32);
    #####:  863:                length = 4;
    #####:  864:                break;
        -:  865:        }
        -:  866:
    #####:  867:        if (expect_val != actual_val)
        -:  868:        {
    #####:  869:            if ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))
        -:  870:            {   /* For UINT, remove sign extension (padding 1's) from signed type casts above */
    #####:  871:                UNITY_INT mask = 1;
    #####:  872:                mask = (mask << 8 * length) - 1;
    #####:  873:                expect_val &= mask;
    #####:  874:                actual_val &= mask;
        -:  875:            }
    #####:  876:            UnityTestResultsFailBegin(lineNumber);
    #####:  877:            UnityPrint(UnityStrElement);
    #####:  878:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####:  879:            UnityPrint(UnityStrExpected);
    #####:  880:            UnityPrintNumberByStyle(expect_val, style);
    #####:  881:            UnityPrint(UnityStrWas);
    #####:  882:            UnityPrintNumberByStyle(actual_val, style);
    #####:  883:            UnityAddMsgIfSpecified(msg);
    #####:  884:            UNITY_FAIL_AND_BAIL;
        -:  885:        }
        -:  886:        /* Walk through array by incrementing the pointers */
    #####:  887:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -:  888:        {
    #####:  889:            expected = (UNITY_INTERNAL_PTR)((const char*)expected + increment);
        -:  890:        }
    #####:  891:        actual = (UNITY_INTERNAL_PTR)((const char*)actual + increment);
        -:  892:    }
        -:  893:}
        -:  894:
        -:  895:/*-----------------------------------------------*/
        -:  896:#ifndef UNITY_EXCLUDE_FLOAT
        -:  897:/* Wrap this define in a function with variable types as float or double */
        -:  898:#define UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff)                           \
        -:  899:    if (UNITY_IS_INF(expected) && UNITY_IS_INF(actual) && (((expected) < 0) == ((actual) < 0))) return 1;   \
        -:  900:    if (UNITY_NAN_CHECK) return 1;                                                            \
        -:  901:    (diff) = (actual) - (expected);                                                           \
        -:  902:    if ((diff) < 0) (diff) = -(diff);                                                         \
        -:  903:    if ((delta) < 0) (delta) = -(delta);                                                      \
        -:  904:    return !(UNITY_IS_NAN(diff) || UNITY_IS_INF(diff) || ((diff) > (delta)))
        -:  905:    /* This first part of this condition will catch any NaN or Infinite values */
        -:  906:#ifndef UNITY_NAN_NOT_EQUAL_NAN
        -:  907:  #define UNITY_NAN_CHECK UNITY_IS_NAN(expected) && UNITY_IS_NAN(actual)
        -:  908:#else
        -:  909:  #define UNITY_NAN_CHECK 0
        -:  910:#endif
        -:  911:
        -:  912:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -:  913:  #define UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual) \
        -:  914:  do {                                                            \
        -:  915:    UnityPrint(UnityStrExpected);                                 \
        -:  916:    UnityPrintFloat(expected);                                    \
        -:  917:    UnityPrint(UnityStrWas);                                      \
        -:  918:    UnityPrintFloat(actual);                                      \
        -:  919:  } while (0)
        -:  920:#else
        -:  921:  #define UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual) \
        -:  922:    UnityPrint(UnityStrDelta)
        -:  923:#endif /* UNITY_EXCLUDE_FLOAT_PRINT */
        -:  924:
        -:  925:/*-----------------------------------------------*/
    #####:  926:static int UnityFloatsWithin(UNITY_FLOAT delta, UNITY_FLOAT expected, UNITY_FLOAT actual)
        -:  927:{
        -:  928:    UNITY_FLOAT diff;
    #####:  929:    UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff);
        -:  930:}
        -:  931:
        -:  932:/*-----------------------------------------------*/
    #####:  933:void UnityAssertWithinFloatArray(const UNITY_FLOAT delta,
        -:  934:                                 UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* expected,
        -:  935:                                 UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* actual,
        -:  936:                                 const UNITY_UINT32 num_elements,
        -:  937:                                 const char* msg,
        -:  938:                                 const UNITY_LINE_TYPE lineNumber,
        -:  939:                                 const UNITY_FLAGS_T flags)
        -:  940:{
    #####:  941:    UNITY_UINT32 elements = num_elements;
    #####:  942:    UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* ptr_expected = expected;
    #####:  943:    UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* ptr_actual = actual;
    #####:  944:    UNITY_FLOAT in_delta = delta;
    #####:  945:    UNITY_FLOAT current_element_delta = delta;
        -:  946:
    #####:  947:    RETURN_IF_FAIL_OR_IGNORE;
        -:  948:
    #####:  949:    if (elements == 0)
        -:  950:    {
        -:  951:#ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY
        -:  952:        UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);
        -:  953:#else
    #####:  954:        UnityPrintPointlessAndBail();
        -:  955:#endif
        -:  956:    }
        -:  957:
    #####:  958:    if (UNITY_IS_INF(in_delta))
        -:  959:    {
    #####:  960:        return; /* Arrays will be force equal with infinite delta */
        -:  961:    }
        -:  962:
    #####:  963:    if (UNITY_IS_NAN(in_delta))
        -:  964:    {
        -:  965:        /* Delta must be correct number */
    #####:  966:        UnityPrintPointlessAndBail();
        -:  967:    }
        -:  968:
    #####:  969:    if (expected == actual)
        -:  970:    {
    #####:  971:        return; /* Both are NULL or same pointer */
        -:  972:    }
        -:  973:
    #####:  974:    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))
        -:  975:    {
    #####:  976:        UNITY_FAIL_AND_BAIL;
        -:  977:    }
        -:  978:
        -:  979:    /* fix delta sign if need */
    #####:  980:    if (in_delta < 0)
        -:  981:    {
    #####:  982:        in_delta = -in_delta;
        -:  983:    }
        -:  984:
    #####:  985:    while (elements--)
        -:  986:    {
    #####:  987:        current_element_delta = *ptr_expected * UNITY_FLOAT_PRECISION;
        -:  988:
    #####:  989:        if (current_element_delta < 0)
        -:  990:        {
        -:  991:            /* fix delta sign for correct calculations */
    #####:  992:            current_element_delta = -current_element_delta;
        -:  993:        }
        -:  994:
    #####:  995:        if (!UnityFloatsWithin(in_delta + current_element_delta, *ptr_expected, *ptr_actual))
        -:  996:        {
    #####:  997:            UnityTestResultsFailBegin(lineNumber);
    #####:  998:            UnityPrint(UnityStrElement);
    #####:  999:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####: 1000:            UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)*ptr_expected, (UNITY_DOUBLE)*ptr_actual);
    #####: 1001:            UnityAddMsgIfSpecified(msg);
    #####: 1002:            UNITY_FAIL_AND_BAIL;
        -: 1003:        }
    #####: 1004:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1005:        {
    #####: 1006:            ptr_expected++;
        -: 1007:        }
    #####: 1008:        ptr_actual++;
        -: 1009:    }
        -: 1010:}
        -: 1011:
        -: 1012:/*-----------------------------------------------*/
    #####: 1013:void UnityAssertFloatsWithin(const UNITY_FLOAT delta,
        -: 1014:                             const UNITY_FLOAT expected,
        -: 1015:                             const UNITY_FLOAT actual,
        -: 1016:                             const char* msg,
        -: 1017:                             const UNITY_LINE_TYPE lineNumber)
        -: 1018:{
    #####: 1019:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1020:
        -: 1021:
    #####: 1022:    if (!UnityFloatsWithin(delta, expected, actual))
        -: 1023:    {
    #####: 1024:        UnityTestResultsFailBegin(lineNumber);
    #####: 1025:        UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)expected, (UNITY_DOUBLE)actual);
    #####: 1026:        UnityAddMsgIfSpecified(msg);
    #####: 1027:        UNITY_FAIL_AND_BAIL;
        -: 1028:    }
    #####: 1029:}
        -: 1030:
        -: 1031:/*-----------------------------------------------*/
    #####: 1032:void UnityAssertFloatsNotWithin(const UNITY_FLOAT delta,
        -: 1033:                                const UNITY_FLOAT expected,
        -: 1034:                                const UNITY_FLOAT actual,
        -: 1035:                                const char* msg,
        -: 1036:                                const UNITY_LINE_TYPE lineNumber)
        -: 1037:{
    #####: 1038:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1039:
    #####: 1040:    if (UnityFloatsWithin(delta, expected, actual))
        -: 1041:    {
    #####: 1042:        UnityTestResultsFailBegin(lineNumber);
    #####: 1043:        UnityPrint(UnityStrExpected);
    #####: 1044:        UnityPrintFloat((UNITY_DOUBLE)expected);
    #####: 1045:        UnityPrint(UnityStrNotEqual);
    #####: 1046:        UnityPrintFloat((UNITY_DOUBLE)actual);
    #####: 1047:        UnityAddMsgIfSpecified(msg);
    #####: 1048:        UNITY_FAIL_AND_BAIL;
        -: 1049:    }
    #####: 1050:}
        -: 1051:
        -: 1052:/*-----------------------------------------------*/
    #####: 1053:void UnityAssertGreaterOrLessFloat(const UNITY_FLOAT threshold,
        -: 1054:                                   const UNITY_FLOAT actual,
        -: 1055:                                   const UNITY_COMPARISON_T compare,
        -: 1056:                                   const char* msg,
        -: 1057:                                   const UNITY_LINE_TYPE lineNumber)
        -: 1058:{
        -: 1059:    int failed;
        -: 1060:
    #####: 1061:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1062:
    #####: 1063:    failed = 0;
        -: 1064:
        -: 1065:    /* Checking for "not success" rather than failure to get the right result for NaN */
    #####: 1066:    if (!(actual < threshold) && (compare & UNITY_SMALLER_THAN)) { failed = 1; }
    #####: 1067:    if (!(actual > threshold) && (compare & UNITY_GREATER_THAN)) { failed = 1; }
        -: 1068:
    #####: 1069:    if ((compare & UNITY_EQUAL_TO) && UnityFloatsWithin(threshold * UNITY_FLOAT_PRECISION, threshold, actual)) { failed = 0; }
        -: 1070:
    #####: 1071:    if (failed)
        -: 1072:    {
    #####: 1073:        UnityTestResultsFailBegin(lineNumber);
    #####: 1074:        UnityPrint(UnityStrExpected);
    #####: 1075:        UnityPrintFloat(actual);
    #####: 1076:        if (compare & UNITY_GREATER_THAN) { UnityPrint(UnityStrGt); }
    #####: 1077:        if (compare & UNITY_SMALLER_THAN) { UnityPrint(UnityStrLt); }
    #####: 1078:        if (compare & UNITY_EQUAL_TO)     { UnityPrint(UnityStrOrEqual);  }
    #####: 1079:        UnityPrintFloat(threshold);
    #####: 1080:        UnityAddMsgIfSpecified(msg);
    #####: 1081:        UNITY_FAIL_AND_BAIL;
        -: 1082:    }
    #####: 1083:}
        -: 1084:
        -: 1085:/*-----------------------------------------------*/
    #####: 1086:void UnityAssertFloatSpecial(const UNITY_FLOAT actual,
        -: 1087:                             const char* msg,
        -: 1088:                             const UNITY_LINE_TYPE lineNumber,
        -: 1089:                             const UNITY_FLOAT_TRAIT_T style)
        -: 1090:{
    #####: 1091:    const char* trait_names[] = {UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet};
    #####: 1092:    UNITY_INT should_be_trait = ((UNITY_INT)style & 1);
    #####: 1093:    UNITY_INT is_trait        = !should_be_trait;
    #####: 1094:    UNITY_INT trait_index     = (UNITY_INT)(style >> 1);
        -: 1095:
    #####: 1096:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1097:
    #####: 1098:    switch (style)
        -: 1099:    {
    #####: 1100:        case UNITY_FLOAT_IS_INF:
        -: 1101:        case UNITY_FLOAT_IS_NOT_INF:
    #####: 1102:            is_trait = UNITY_IS_INF(actual) && (actual > 0);
    #####: 1103:            break;
    #####: 1104:        case UNITY_FLOAT_IS_NEG_INF:
        -: 1105:        case UNITY_FLOAT_IS_NOT_NEG_INF:
    #####: 1106:            is_trait = UNITY_IS_INF(actual) && (actual < 0);
    #####: 1107:            break;
        -: 1108:
    #####: 1109:        case UNITY_FLOAT_IS_NAN:
        -: 1110:        case UNITY_FLOAT_IS_NOT_NAN:
    #####: 1111:            is_trait = UNITY_IS_NAN(actual) ? 1 : 0;
    #####: 1112:            break;
        -: 1113:
    #####: 1114:        case UNITY_FLOAT_IS_DET: /* A determinate number is non infinite and not NaN. */
        -: 1115:        case UNITY_FLOAT_IS_NOT_DET:
    #####: 1116:            is_trait = !UNITY_IS_INF(actual) && !UNITY_IS_NAN(actual);
    #####: 1117:            break;
        -: 1118:
    #####: 1119:        case UNITY_FLOAT_INVALID_TRAIT:  /* Supress warning */
        -: 1120:        default: /* including UNITY_FLOAT_INVALID_TRAIT */
    #####: 1121:            trait_index = 0;
    #####: 1122:            trait_names[0] = UnityStrInvalidFloatTrait;
    #####: 1123:            break;
        -: 1124:    }
        -: 1125:
    #####: 1126:    if (is_trait != should_be_trait)
        -: 1127:    {
    #####: 1128:        UnityTestResultsFailBegin(lineNumber);
    #####: 1129:        UnityPrint(UnityStrExpected);
    #####: 1130:        if (!should_be_trait)
        -: 1131:        {
    #####: 1132:            UnityPrint(UnityStrNot);
        -: 1133:        }
    #####: 1134:        UnityPrint(trait_names[trait_index]);
    #####: 1135:        UnityPrint(UnityStrWas);
        -: 1136:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
    #####: 1137:        UnityPrintFloat((UNITY_DOUBLE)actual);
        -: 1138:#else
        -: 1139:        if (should_be_trait)
        -: 1140:        {
        -: 1141:            UnityPrint(UnityStrNot);
        -: 1142:        }
        -: 1143:        UnityPrint(trait_names[trait_index]);
        -: 1144:#endif
    #####: 1145:        UnityAddMsgIfSpecified(msg);
    #####: 1146:        UNITY_FAIL_AND_BAIL;
        -: 1147:    }
    #####: 1148:}
        -: 1149:
        -: 1150:#endif /* not UNITY_EXCLUDE_FLOAT */
        -: 1151:
        -: 1152:/*-----------------------------------------------*/
        -: 1153:#ifndef UNITY_EXCLUDE_DOUBLE
        -: 1154:static int UnityDoublesWithin(UNITY_DOUBLE delta, UNITY_DOUBLE expected, UNITY_DOUBLE actual)
        -: 1155:{
        -: 1156:    UNITY_DOUBLE diff;
        -: 1157:    UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff);
        -: 1158:}
        -: 1159:
        -: 1160:/*-----------------------------------------------*/
        -: 1161:void UnityAssertWithinDoubleArray(const UNITY_DOUBLE delta,
        -: 1162:                                  UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* expected,
        -: 1163:                                  UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* actual,
        -: 1164:                                  const UNITY_UINT32 num_elements,
        -: 1165:                                  const char* msg,
        -: 1166:                                  const UNITY_LINE_TYPE lineNumber,
        -: 1167:                                  const UNITY_FLAGS_T flags)
        -: 1168:{
        -: 1169:    UNITY_UINT32 elements = num_elements;
        -: 1170:    UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* ptr_expected = expected;
        -: 1171:    UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* ptr_actual = actual;
        -: 1172:    UNITY_DOUBLE in_delta = delta;
        -: 1173:    UNITY_DOUBLE current_element_delta = delta;
        -: 1174:
        -: 1175:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1176:
        -: 1177:    if (elements == 0)
        -: 1178:    {
        -: 1179:#ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY
        -: 1180:        UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);
        -: 1181:#else
        -: 1182:        UnityPrintPointlessAndBail();
        -: 1183:#endif
        -: 1184:    }
        -: 1185:
        -: 1186:    if (UNITY_IS_INF(in_delta))
        -: 1187:    {
        -: 1188:        return; /* Arrays will be force equal with infinite delta */
        -: 1189:    }
        -: 1190:
        -: 1191:    if (UNITY_IS_NAN(in_delta))
        -: 1192:    {
        -: 1193:        /* Delta must be correct number */
        -: 1194:        UnityPrintPointlessAndBail();
        -: 1195:    }
        -: 1196:
        -: 1197:    if (expected == actual)
        -: 1198:    {
        -: 1199:        return; /* Both are NULL or same pointer */
        -: 1200:    }
        -: 1201:
        -: 1202:    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))
        -: 1203:    {
        -: 1204:        UNITY_FAIL_AND_BAIL;
        -: 1205:    }
        -: 1206:
        -: 1207:    /* fix delta sign if need */
        -: 1208:    if (in_delta < 0)
        -: 1209:    {
        -: 1210:        in_delta = -in_delta;
        -: 1211:    }
        -: 1212:
        -: 1213:    while (elements--)
        -: 1214:    {
        -: 1215:        current_element_delta = *ptr_expected * UNITY_DOUBLE_PRECISION;
        -: 1216:
        -: 1217:        if (current_element_delta < 0)
        -: 1218:        {
        -: 1219:            /* fix delta sign for correct calculations */
        -: 1220:            current_element_delta = -current_element_delta;
        -: 1221:        }
        -: 1222:
        -: 1223:        if (!UnityDoublesWithin(in_delta + current_element_delta, *ptr_expected, *ptr_actual))
        -: 1224:        {
        -: 1225:            UnityTestResultsFailBegin(lineNumber);
        -: 1226:            UnityPrint(UnityStrElement);
        -: 1227:            UnityPrintNumberUnsigned(num_elements - elements - 1);
        -: 1228:            UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(*ptr_expected, *ptr_actual);
        -: 1229:            UnityAddMsgIfSpecified(msg);
        -: 1230:            UNITY_FAIL_AND_BAIL;
        -: 1231:        }
        -: 1232:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1233:        {
        -: 1234:            ptr_expected++;
        -: 1235:        }
        -: 1236:        ptr_actual++;
        -: 1237:    }
        -: 1238:}
        -: 1239:
        -: 1240:/*-----------------------------------------------*/
        -: 1241:void UnityAssertDoublesWithin(const UNITY_DOUBLE delta,
        -: 1242:                              const UNITY_DOUBLE expected,
        -: 1243:                              const UNITY_DOUBLE actual,
        -: 1244:                              const char* msg,
        -: 1245:                              const UNITY_LINE_TYPE lineNumber)
        -: 1246:{
        -: 1247:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1248:
        -: 1249:    if (!UnityDoublesWithin(delta, expected, actual))
        -: 1250:    {
        -: 1251:        UnityTestResultsFailBegin(lineNumber);
        -: 1252:        UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual);
        -: 1253:        UnityAddMsgIfSpecified(msg);
        -: 1254:        UNITY_FAIL_AND_BAIL;
        -: 1255:    }
        -: 1256:}
        -: 1257:
        -: 1258:/*-----------------------------------------------*/
        -: 1259:void UnityAssertDoublesNotWithin(const UNITY_DOUBLE delta,
        -: 1260:                                 const UNITY_DOUBLE expected,
        -: 1261:                                 const UNITY_DOUBLE actual,
        -: 1262:                                 const char* msg,
        -: 1263:                                 const UNITY_LINE_TYPE lineNumber)
        -: 1264:{
        -: 1265:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1266:
        -: 1267:    if (UnityDoublesWithin(delta, expected, actual))
        -: 1268:    {
        -: 1269:        UnityTestResultsFailBegin(lineNumber);
        -: 1270:        UnityPrint(UnityStrExpected);
        -: 1271:        UnityPrintFloat((UNITY_DOUBLE)expected);
        -: 1272:        UnityPrint(UnityStrNotEqual);
        -: 1273:        UnityPrintFloat((UNITY_DOUBLE)actual);
        -: 1274:        UnityAddMsgIfSpecified(msg);
        -: 1275:        UNITY_FAIL_AND_BAIL;
        -: 1276:    }
        -: 1277:}
        -: 1278:
        -: 1279:/*-----------------------------------------------*/
        -: 1280:void UnityAssertGreaterOrLessDouble(const UNITY_DOUBLE threshold,
        -: 1281:                                    const UNITY_DOUBLE actual,
        -: 1282:                                    const UNITY_COMPARISON_T compare,
        -: 1283:                                    const char* msg,
        -: 1284:                                    const UNITY_LINE_TYPE lineNumber)
        -: 1285:{
        -: 1286:    int failed;
        -: 1287:
        -: 1288:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1289:
        -: 1290:    failed = 0;
        -: 1291:
        -: 1292:    /* Checking for "not success" rather than failure to get the right result for NaN */
        -: 1293:    if (!(actual < threshold) && (compare & UNITY_SMALLER_THAN)) { failed = 1; }
        -: 1294:    if (!(actual > threshold) && (compare & UNITY_GREATER_THAN)) { failed = 1; }
        -: 1295:
        -: 1296:    if ((compare & UNITY_EQUAL_TO) && UnityDoublesWithin(threshold * UNITY_DOUBLE_PRECISION, threshold, actual)) { failed = 0; }
        -: 1297:
        -: 1298:    if (failed)
        -: 1299:    {
        -: 1300:        UnityTestResultsFailBegin(lineNumber);
        -: 1301:        UnityPrint(UnityStrExpected);
        -: 1302:        UnityPrintFloat(actual);
        -: 1303:        if (compare & UNITY_GREATER_THAN) { UnityPrint(UnityStrGt); }
        -: 1304:        if (compare & UNITY_SMALLER_THAN) { UnityPrint(UnityStrLt); }
        -: 1305:        if (compare & UNITY_EQUAL_TO)     { UnityPrint(UnityStrOrEqual);  }
        -: 1306:        UnityPrintFloat(threshold);
        -: 1307:        UnityAddMsgIfSpecified(msg);
        -: 1308:        UNITY_FAIL_AND_BAIL;
        -: 1309:    }
        -: 1310:}
        -: 1311:
        -: 1312:/*-----------------------------------------------*/
        -: 1313:void UnityAssertDoubleSpecial(const UNITY_DOUBLE actual,
        -: 1314:                              const char* msg,
        -: 1315:                              const UNITY_LINE_TYPE lineNumber,
        -: 1316:                              const UNITY_FLOAT_TRAIT_T style)
        -: 1317:{
        -: 1318:    const char* trait_names[] = {UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet};
        -: 1319:    UNITY_INT should_be_trait = ((UNITY_INT)style & 1);
        -: 1320:    UNITY_INT is_trait        = !should_be_trait;
        -: 1321:    UNITY_INT trait_index     = (UNITY_INT)(style >> 1);
        -: 1322:
        -: 1323:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1324:
        -: 1325:    switch (style)
        -: 1326:    {
        -: 1327:        case UNITY_FLOAT_IS_INF:
        -: 1328:        case UNITY_FLOAT_IS_NOT_INF:
        -: 1329:            is_trait = UNITY_IS_INF(actual) && (actual > 0);
        -: 1330:            break;
        -: 1331:        case UNITY_FLOAT_IS_NEG_INF:
        -: 1332:        case UNITY_FLOAT_IS_NOT_NEG_INF:
        -: 1333:            is_trait = UNITY_IS_INF(actual) && (actual < 0);
        -: 1334:            break;
        -: 1335:
        -: 1336:        case UNITY_FLOAT_IS_NAN:
        -: 1337:        case UNITY_FLOAT_IS_NOT_NAN:
        -: 1338:            is_trait = UNITY_IS_NAN(actual) ? 1 : 0;
        -: 1339:            break;
        -: 1340:
        -: 1341:        case UNITY_FLOAT_IS_DET: /* A determinate number is non infinite and not NaN. */
        -: 1342:        case UNITY_FLOAT_IS_NOT_DET:
        -: 1343:            is_trait = !UNITY_IS_INF(actual) && !UNITY_IS_NAN(actual);
        -: 1344:            break;
        -: 1345:
        -: 1346:        case UNITY_FLOAT_INVALID_TRAIT:  /* Supress warning */
        -: 1347:        default: /* including UNITY_FLOAT_INVALID_TRAIT */
        -: 1348:            trait_index = 0;
        -: 1349:            trait_names[0] = UnityStrInvalidFloatTrait;
        -: 1350:            break;
        -: 1351:    }
        -: 1352:
        -: 1353:    if (is_trait != should_be_trait)
        -: 1354:    {
        -: 1355:        UnityTestResultsFailBegin(lineNumber);
        -: 1356:        UnityPrint(UnityStrExpected);
        -: 1357:        if (!should_be_trait)
        -: 1358:        {
        -: 1359:            UnityPrint(UnityStrNot);
        -: 1360:        }
        -: 1361:        UnityPrint(trait_names[trait_index]);
        -: 1362:        UnityPrint(UnityStrWas);
        -: 1363:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -: 1364:        UnityPrintFloat(actual);
        -: 1365:#else
        -: 1366:        if (should_be_trait)
        -: 1367:        {
        -: 1368:            UnityPrint(UnityStrNot);
        -: 1369:        }
        -: 1370:        UnityPrint(trait_names[trait_index]);
        -: 1371:#endif
        -: 1372:        UnityAddMsgIfSpecified(msg);
        -: 1373:        UNITY_FAIL_AND_BAIL;
        -: 1374:    }
        -: 1375:}
        -: 1376:
        -: 1377:#endif /* not UNITY_EXCLUDE_DOUBLE */
        -: 1378:
        -: 1379:/*-----------------------------------------------*/
    #####: 1380:void UnityAssertNumbersWithin(const UNITY_UINT delta,
        -: 1381:                              const UNITY_INT expected,
        -: 1382:                              const UNITY_INT actual,
        -: 1383:                              const char* msg,
        -: 1384:                              const UNITY_LINE_TYPE lineNumber,
        -: 1385:                              const UNITY_DISPLAY_STYLE_T style)
        -: 1386:{
    #####: 1387:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1388:
    #####: 1389:    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1390:    {
    #####: 1391:        if (actual > expected)
        -: 1392:        {
    #####: 1393:            Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);
        -: 1394:        }
        -: 1395:        else
        -: 1396:        {
    #####: 1397:            Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);
        -: 1398:        }
        -: 1399:    }
        -: 1400:    else
        -: 1401:    {
    #####: 1402:        if ((UNITY_UINT)actual > (UNITY_UINT)expected)
        -: 1403:        {
    #####: 1404:            Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);
        -: 1405:        }
        -: 1406:        else
        -: 1407:        {
    #####: 1408:            Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);
        -: 1409:        }
        -: 1410:    }
        -: 1411:
    #####: 1412:    if (Unity.CurrentTestFailed)
        -: 1413:    {
    #####: 1414:        UnityTestResultsFailBegin(lineNumber);
    #####: 1415:        UnityPrint(UnityStrDelta);
    #####: 1416:        UnityPrintNumberByStyle((UNITY_INT)delta, style);
    #####: 1417:        UnityPrint(UnityStrExpected);
    #####: 1418:        UnityPrintNumberByStyle(expected, style);
    #####: 1419:        UnityPrint(UnityStrWas);
    #####: 1420:        UnityPrintNumberByStyle(actual, style);
    #####: 1421:        UnityAddMsgIfSpecified(msg);
    #####: 1422:        UNITY_FAIL_AND_BAIL;
        -: 1423:    }
    #####: 1424:}
        -: 1425:
        -: 1426:/*-----------------------------------------------*/
    #####: 1427:void UnityAssertNumbersArrayWithin(const UNITY_UINT delta,
        -: 1428:                                   UNITY_INTERNAL_PTR expected,
        -: 1429:                                   UNITY_INTERNAL_PTR actual,
        -: 1430:                                   const UNITY_UINT32 num_elements,
        -: 1431:                                   const char* msg,
        -: 1432:                                   const UNITY_LINE_TYPE lineNumber,
        -: 1433:                                   const UNITY_DISPLAY_STYLE_T style,
        -: 1434:                                   const UNITY_FLAGS_T flags)
        -: 1435:{
    #####: 1436:    UNITY_UINT32 elements = num_elements;
    #####: 1437:    unsigned int length   = style & 0xF;
    #####: 1438:    unsigned int increment = 0;
        -: 1439:
    #####: 1440:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1441:
    #####: 1442:    if (num_elements == 0)
        -: 1443:    {
        -: 1444:#ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY
        -: 1445:        UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);
        -: 1446:#else
    #####: 1447:        UnityPrintPointlessAndBail();
        -: 1448:#endif
        -: 1449:    }
        -: 1450:
    #####: 1451:    if (expected == actual)
        -: 1452:    {
    #####: 1453:        return; /* Both are NULL or same pointer */
        -: 1454:    }
        -: 1455:
    #####: 1456:    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))
        -: 1457:    {
    #####: 1458:        UNITY_FAIL_AND_BAIL;
        -: 1459:    }
        -: 1460:
    #####: 1461:    while ((elements > 0) && (elements--))
        -: 1462:    {
        -: 1463:        UNITY_INT expect_val;
        -: 1464:        UNITY_INT actual_val;
        -: 1465:
    #####: 1466:        switch (length)
        -: 1467:        {
    #####: 1468:            case 1:
        -: 1469:                /* fixing problems with signed overflow on unsigned numbers */
    #####: 1470:                if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1471:                {
    #####: 1472:                    expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)expected;
    #####: 1473:                    actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)actual;
    #####: 1474:                    increment  = sizeof(UNITY_INT8);
        -: 1475:                }
        -: 1476:                else
        -: 1477:                {
    #####: 1478:                    expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE const UNITY_UINT8*)expected;
    #####: 1479:                    actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE const UNITY_UINT8*)actual;
    #####: 1480:                    increment  = sizeof(UNITY_UINT8);
        -: 1481:                }
    #####: 1482:                break;
        -: 1483:
    #####: 1484:            case 2:
        -: 1485:                /* fixing problems with signed overflow on unsigned numbers */
    #####: 1486:                if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1487:                {
    #####: 1488:                    expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)expected;
    #####: 1489:                    actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)actual;
    #####: 1490:                    increment  = sizeof(UNITY_INT16);
        -: 1491:                }
        -: 1492:                else
        -: 1493:                {
    #####: 1494:                    expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE const UNITY_UINT16*)expected;
    #####: 1495:                    actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE const UNITY_UINT16*)actual;
    #####: 1496:                    increment  = sizeof(UNITY_UINT16);
        -: 1497:                }
    #####: 1498:                break;
        -: 1499:
        -: 1500:#ifdef UNITY_SUPPORT_64
    #####: 1501:            case 8:
        -: 1502:                /* fixing problems with signed overflow on unsigned numbers */
    #####: 1503:                if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1504:                {
    #####: 1505:                    expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)expected;
    #####: 1506:                    actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)actual;
    #####: 1507:                    increment  = sizeof(UNITY_INT64);
        -: 1508:                }
        -: 1509:                else
        -: 1510:                {
    #####: 1511:                    expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE const UNITY_UINT64*)expected;
    #####: 1512:                    actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE const UNITY_UINT64*)actual;
    #####: 1513:                    increment  = sizeof(UNITY_UINT64);
        -: 1514:                }
    #####: 1515:                break;
        -: 1516:#endif
        -: 1517:
    #####: 1518:            default: /* default is length 4 bytes */
        -: 1519:            case 4:
        -: 1520:                /* fixing problems with signed overflow on unsigned numbers */
    #####: 1521:                if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1522:                {
    #####: 1523:                    expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)expected;
    #####: 1524:                    actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)actual;
    #####: 1525:                    increment  = sizeof(UNITY_INT32);
        -: 1526:                }
        -: 1527:                else
        -: 1528:                {
    #####: 1529:                    expect_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE const UNITY_UINT32*)expected;
    #####: 1530:                    actual_val = (UNITY_INT)*(UNITY_PTR_ATTRIBUTE const UNITY_UINT32*)actual;
    #####: 1531:                    increment  = sizeof(UNITY_UINT32);
        -: 1532:                }
    #####: 1533:                length = 4;
    #####: 1534:                break;
        -: 1535:        }
        -: 1536:
    #####: 1537:        if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1538:        {
    #####: 1539:            if (actual_val > expect_val)
        -: 1540:            {
    #####: 1541:                Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);
        -: 1542:            }
        -: 1543:            else
        -: 1544:            {
    #####: 1545:                Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);
        -: 1546:            }
        -: 1547:        }
        -: 1548:        else
        -: 1549:        {
    #####: 1550:            if ((UNITY_UINT)actual_val > (UNITY_UINT)expect_val)
        -: 1551:            {
    #####: 1552:                Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);
        -: 1553:            }
        -: 1554:            else
        -: 1555:            {
    #####: 1556:                Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);
        -: 1557:            }
        -: 1558:        }
        -: 1559:
    #####: 1560:        if (Unity.CurrentTestFailed)
        -: 1561:        {
    #####: 1562:            if ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))
        -: 1563:            {   /* For UINT, remove sign extension (padding 1's) from signed type casts above */
    #####: 1564:                UNITY_INT mask = 1;
    #####: 1565:                mask = (mask << 8 * length) - 1;
    #####: 1566:                expect_val &= mask;
    #####: 1567:                actual_val &= mask;
        -: 1568:            }
    #####: 1569:            UnityTestResultsFailBegin(lineNumber);
    #####: 1570:            UnityPrint(UnityStrDelta);
    #####: 1571:            UnityPrintNumberByStyle((UNITY_INT)delta, style);
    #####: 1572:            UnityPrint(UnityStrElement);
    #####: 1573:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####: 1574:            UnityPrint(UnityStrExpected);
    #####: 1575:            UnityPrintNumberByStyle(expect_val, style);
    #####: 1576:            UnityPrint(UnityStrWas);
    #####: 1577:            UnityPrintNumberByStyle(actual_val, style);
    #####: 1578:            UnityAddMsgIfSpecified(msg);
    #####: 1579:            UNITY_FAIL_AND_BAIL;
        -: 1580:        }
        -: 1581:        /* Walk through array by incrementing the pointers */
    #####: 1582:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1583:        {
    #####: 1584:            expected = (UNITY_INTERNAL_PTR)((const char*)expected + increment);
        -: 1585:        }
    #####: 1586:        actual = (UNITY_INTERNAL_PTR)((const char*)actual + increment);
        -: 1587:    }
        -: 1588:}
        -: 1589:
        -: 1590:/*-----------------------------------------------*/
    #####: 1591:void UnityAssertEqualString(const char* expected,
        -: 1592:                            const char* actual,
        -: 1593:                            const char* msg,
        -: 1594:                            const UNITY_LINE_TYPE lineNumber)
        -: 1595:{
        -: 1596:    UNITY_UINT32 i;
        -: 1597:
    #####: 1598:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1599:
        -: 1600:    /* if both pointers not null compare the strings */
    #####: 1601:    if (expected && actual)
        -: 1602:    {
    #####: 1603:        for (i = 0; expected[i] || actual[i]; i++)
        -: 1604:        {
    #####: 1605:            if (expected[i] != actual[i])
        -: 1606:            {
    #####: 1607:                Unity.CurrentTestFailed = 1;
    #####: 1608:                break;
        -: 1609:            }
        -: 1610:        }
        -: 1611:    }
        -: 1612:    else
        -: 1613:    { /* fail if either null but not if both */
    #####: 1614:        if (expected || actual)
        -: 1615:        {
    #####: 1616:            Unity.CurrentTestFailed = 1;
        -: 1617:        }
        -: 1618:    }
        -: 1619:
    #####: 1620:    if (Unity.CurrentTestFailed)
        -: 1621:    {
    #####: 1622:        UnityTestResultsFailBegin(lineNumber);
    #####: 1623:        UnityPrintExpectedAndActualStrings(expected, actual);
    #####: 1624:        UnityAddMsgIfSpecified(msg);
    #####: 1625:        UNITY_FAIL_AND_BAIL;
        -: 1626:    }
    #####: 1627:}
        -: 1628:
        -: 1629:/*-----------------------------------------------*/
    #####: 1630:void UnityAssertEqualStringLen(const char* expected,
        -: 1631:                               const char* actual,
        -: 1632:                               const UNITY_UINT32 length,
        -: 1633:                               const char* msg,
        -: 1634:                               const UNITY_LINE_TYPE lineNumber)
        -: 1635:{
        -: 1636:    UNITY_UINT32 i;
        -: 1637:
    #####: 1638:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1639:
        -: 1640:    /* if both pointers not null compare the strings */
    #####: 1641:    if (expected && actual)
        -: 1642:    {
    #####: 1643:        for (i = 0; (i < length) && (expected[i] || actual[i]); i++)
        -: 1644:        {
    #####: 1645:            if (expected[i] != actual[i])
        -: 1646:            {
    #####: 1647:                Unity.CurrentTestFailed = 1;
    #####: 1648:                break;
        -: 1649:            }
        -: 1650:        }
        -: 1651:    }
        -: 1652:    else
        -: 1653:    { /* fail if either null but not if both */
    #####: 1654:        if (expected || actual)
        -: 1655:        {
    #####: 1656:            Unity.CurrentTestFailed = 1;
        -: 1657:        }
        -: 1658:    }
        -: 1659:
    #####: 1660:    if (Unity.CurrentTestFailed)
        -: 1661:    {
    #####: 1662:        UnityTestResultsFailBegin(lineNumber);
    #####: 1663:        UnityPrintExpectedAndActualStringsLen(expected, actual, length);
    #####: 1664:        UnityAddMsgIfSpecified(msg);
    #####: 1665:        UNITY_FAIL_AND_BAIL;
        -: 1666:    }
    #####: 1667:}
        -: 1668:
        -: 1669:/*-----------------------------------------------*/
    #####: 1670:void UnityAssertEqualStringArray(UNITY_INTERNAL_PTR expected,
        -: 1671:                                 const char** actual,
        -: 1672:                                 const UNITY_UINT32 num_elements,
        -: 1673:                                 const char* msg,
        -: 1674:                                 const UNITY_LINE_TYPE lineNumber,
        -: 1675:                                 const UNITY_FLAGS_T flags)
        -: 1676:{
    #####: 1677:    UNITY_UINT32 i = 0;
    #####: 1678:    UNITY_UINT32 j = 0;
    #####: 1679:    const char* expd = NULL;
    #####: 1680:    const char* act = NULL;
        -: 1681:
    #####: 1682:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1683:
        -: 1684:    /* if no elements, it's an error */
    #####: 1685:    if (num_elements == 0)
        -: 1686:    {
        -: 1687:#ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY
        -: 1688:        UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);
        -: 1689:#else
    #####: 1690:        UnityPrintPointlessAndBail();
        -: 1691:#endif
        -: 1692:    }
        -: 1693:
    #####: 1694:    if ((const void*)expected == (const void*)actual)
        -: 1695:    {
    #####: 1696:        return; /* Both are NULL or same pointer */
        -: 1697:    }
        -: 1698:
    #####: 1699:    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))
        -: 1700:    {
    #####: 1701:        UNITY_FAIL_AND_BAIL;
        -: 1702:    }
        -: 1703:
    #####: 1704:    if (flags != UNITY_ARRAY_TO_ARRAY)
        -: 1705:    {
    #####: 1706:        expd = (const char*)expected;
        -: 1707:    }
        -: 1708:
        -: 1709:    do
        -: 1710:    {
    #####: 1711:        act = actual[j];
    #####: 1712:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1713:        {
    #####: 1714:            expd = ((const char* const*)expected)[j];
        -: 1715:        }
        -: 1716:
        -: 1717:        /* if both pointers not null compare the strings */
    #####: 1718:        if (expd && act)
        -: 1719:        {
    #####: 1720:            for (i = 0; expd[i] || act[i]; i++)
        -: 1721:            {
    #####: 1722:                if (expd[i] != act[i])
        -: 1723:                {
    #####: 1724:                    Unity.CurrentTestFailed = 1;
    #####: 1725:                    break;
        -: 1726:                }
        -: 1727:            }
        -: 1728:        }
        -: 1729:        else
        -: 1730:        { /* handle case of one pointers being null (if both null, test should pass) */
    #####: 1731:            if (expd != act)
        -: 1732:            {
    #####: 1733:                Unity.CurrentTestFailed = 1;
        -: 1734:            }
        -: 1735:        }
        -: 1736:
    #####: 1737:        if (Unity.CurrentTestFailed)
        -: 1738:        {
    #####: 1739:            UnityTestResultsFailBegin(lineNumber);
    #####: 1740:            if (num_elements > 1)
        -: 1741:            {
    #####: 1742:                UnityPrint(UnityStrElement);
    #####: 1743:                UnityPrintNumberUnsigned(j);
        -: 1744:            }
    #####: 1745:            UnityPrintExpectedAndActualStrings(expd, act);
    #####: 1746:            UnityAddMsgIfSpecified(msg);
    #####: 1747:            UNITY_FAIL_AND_BAIL;
        -: 1748:        }
    #####: 1749:    } while (++j < num_elements);
        -: 1750:}
        -: 1751:
        -: 1752:/*-----------------------------------------------*/
    #####: 1753:void UnityAssertEqualMemory(UNITY_INTERNAL_PTR expected,
        -: 1754:                            UNITY_INTERNAL_PTR actual,
        -: 1755:                            const UNITY_UINT32 length,
        -: 1756:                            const UNITY_UINT32 num_elements,
        -: 1757:                            const char* msg,
        -: 1758:                            const UNITY_LINE_TYPE lineNumber,
        -: 1759:                            const UNITY_FLAGS_T flags)
        -: 1760:{
    #####: 1761:    UNITY_PTR_ATTRIBUTE const unsigned char* ptr_exp = (UNITY_PTR_ATTRIBUTE const unsigned char*)expected;
    #####: 1762:    UNITY_PTR_ATTRIBUTE const unsigned char* ptr_act = (UNITY_PTR_ATTRIBUTE const unsigned char*)actual;
    #####: 1763:    UNITY_UINT32 elements = num_elements;
        -: 1764:    UNITY_UINT32 bytes;
        -: 1765:
    #####: 1766:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1767:
    #####: 1768:    if (elements == 0)
        -: 1769:    {
        -: 1770:#ifdef UNITY_COMPARE_PTRS_ON_ZERO_ARRAY
        -: 1771:        UNITY_TEST_ASSERT_EQUAL_PTR(expected, actual, lineNumber, msg);
        -: 1772:#else
    #####: 1773:        UnityPrintPointlessAndBail();
        -: 1774:#endif
        -: 1775:    }
    #####: 1776:    if (length == 0)
        -: 1777:    {
    #####: 1778:        UnityPrintPointlessAndBail();
        -: 1779:    }
        -: 1780:
    #####: 1781:    if (expected == actual)
        -: 1782:    {
    #####: 1783:        return; /* Both are NULL or same pointer */
        -: 1784:    }
        -: 1785:
    #####: 1786:    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))
        -: 1787:    {
    #####: 1788:        UNITY_FAIL_AND_BAIL;
        -: 1789:    }
        -: 1790:
    #####: 1791:    while (elements--)
        -: 1792:    {
    #####: 1793:        bytes = length;
    #####: 1794:        while (bytes--)
        -: 1795:        {
    #####: 1796:            if (*ptr_exp != *ptr_act)
        -: 1797:            {
    #####: 1798:                UnityTestResultsFailBegin(lineNumber);
    #####: 1799:                UnityPrint(UnityStrMemory);
    #####: 1800:                if (num_elements > 1)
        -: 1801:                {
    #####: 1802:                    UnityPrint(UnityStrElement);
    #####: 1803:                    UnityPrintNumberUnsigned(num_elements - elements - 1);
        -: 1804:                }
    #####: 1805:                UnityPrint(UnityStrByte);
    #####: 1806:                UnityPrintNumberUnsigned(length - bytes - 1);
    #####: 1807:                UnityPrint(UnityStrExpected);
    #####: 1808:                UnityPrintNumberByStyle(*ptr_exp, UNITY_DISPLAY_STYLE_HEX8);
    #####: 1809:                UnityPrint(UnityStrWas);
    #####: 1810:                UnityPrintNumberByStyle(*ptr_act, UNITY_DISPLAY_STYLE_HEX8);
    #####: 1811:                UnityAddMsgIfSpecified(msg);
    #####: 1812:                UNITY_FAIL_AND_BAIL;
        -: 1813:            }
    #####: 1814:            ptr_exp++;
    #####: 1815:            ptr_act++;
        -: 1816:        }
    #####: 1817:        if (flags == UNITY_ARRAY_TO_VAL)
        -: 1818:        {
    #####: 1819:            ptr_exp = (UNITY_PTR_ATTRIBUTE const unsigned char*)expected;
        -: 1820:        }
        -: 1821:    }
        -: 1822:}
        -: 1823:
        -: 1824:/*-----------------------------------------------*/
        -: 1825:
        -: 1826:static union
        -: 1827:{
        -: 1828:    UNITY_INT8 i8;
        -: 1829:    UNITY_INT16 i16;
        -: 1830:    UNITY_INT32 i32;
        -: 1831:#ifdef UNITY_SUPPORT_64
        -: 1832:    UNITY_INT64 i64;
        -: 1833:#endif
        -: 1834:#ifndef UNITY_EXCLUDE_FLOAT
        -: 1835:    float f;
        -: 1836:#endif
        -: 1837:#ifndef UNITY_EXCLUDE_DOUBLE
        -: 1838:    double d;
        -: 1839:#endif
        -: 1840:} UnityQuickCompare;
        -: 1841:
    #####: 1842:UNITY_INTERNAL_PTR UnityNumToPtr(const UNITY_INT num, const UNITY_UINT8 size)
        -: 1843:{
    #####: 1844:    switch(size)
        -: 1845:    {
    #####: 1846:        case 1:
    #####: 1847:            UnityQuickCompare.i8 = (UNITY_INT8)num;
    #####: 1848:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i8);
        -: 1849:
    #####: 1850:        case 2:
    #####: 1851:            UnityQuickCompare.i16 = (UNITY_INT16)num;
    #####: 1852:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i16);
        -: 1853:
        -: 1854:#ifdef UNITY_SUPPORT_64
    #####: 1855:        case 8:
    #####: 1856:            UnityQuickCompare.i64 = (UNITY_INT64)num;
    #####: 1857:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i64);
        -: 1858:#endif
        -: 1859:
    #####: 1860:        default: /* 4 bytes */
    #####: 1861:            UnityQuickCompare.i32 = (UNITY_INT32)num;
    #####: 1862:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i32);
        -: 1863:    }
        -: 1864:}
        -: 1865:
        -: 1866:#ifndef UNITY_EXCLUDE_FLOAT
        -: 1867:/*-----------------------------------------------*/
    #####: 1868:UNITY_INTERNAL_PTR UnityFloatToPtr(const float num)
        -: 1869:{
    #####: 1870:    UnityQuickCompare.f = num;
    #####: 1871:    return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.f);
        -: 1872:}
        -: 1873:#endif
        -: 1874:
        -: 1875:#ifndef UNITY_EXCLUDE_DOUBLE
        -: 1876:/*-----------------------------------------------*/
        -: 1877:UNITY_INTERNAL_PTR UnityDoubleToPtr(const double num)
        -: 1878:{
        -: 1879:    UnityQuickCompare.d = num;
        -: 1880:    return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.d);
        -: 1881:}
        -: 1882:#endif
        -: 1883:
        -: 1884:#ifdef UNITY_INCLUDE_PRINT_FORMATTED
        -: 1885:
        -: 1886:/*-----------------------------------------------
        -: 1887: * printf length modifier helpers
        -: 1888: *-----------------------------------------------*/
        -: 1889:
        -: 1890:enum UnityLengthModifier {
        -: 1891:    UNITY_LENGTH_MODIFIER_NONE,
        -: 1892:    UNITY_LENGTH_MODIFIER_LONG_LONG,
        -: 1893:    UNITY_LENGTH_MODIFIER_LONG,
        -: 1894:};
        -: 1895:
        -: 1896:#define UNITY_EXTRACT_ARG(NUMBER_T, NUMBER, LENGTH_MOD, VA, ARG_T) \
        -: 1897:do {                                                               \
        -: 1898:    switch (LENGTH_MOD)                                            \
        -: 1899:    {                                                              \
        -: 1900:        case UNITY_LENGTH_MODIFIER_LONG_LONG:                      \
        -: 1901:        {                                                          \
        -: 1902:            NUMBER = (NUMBER_T)va_arg(VA, long long ARG_T);        \
        -: 1903:            break;                                                 \
        -: 1904:        }                                                          \
        -: 1905:        case UNITY_LENGTH_MODIFIER_LONG:                           \
        -: 1906:        {                                                          \
        -: 1907:            NUMBER = (NUMBER_T)va_arg(VA, long ARG_T);             \
        -: 1908:            break;                                                 \
        -: 1909:        }                                                          \
        -: 1910:        case UNITY_LENGTH_MODIFIER_NONE:                           \
        -: 1911:        default:                                                   \
        -: 1912:        {                                                          \
        -: 1913:            NUMBER = (NUMBER_T)va_arg(VA, ARG_T);                  \
        -: 1914:            break;                                                 \
        -: 1915:        }                                                          \
        -: 1916:    }                                                              \
        -: 1917:} while (0)
        -: 1918:
        -: 1919:static enum UnityLengthModifier UnityLengthModifierGet(const char *pch, int *length)
        -: 1920:{
        -: 1921:    enum UnityLengthModifier length_mod;
        -: 1922:    switch (pch[0])
        -: 1923:    {
        -: 1924:        case 'l':
        -: 1925:            {
        -: 1926:                if (pch[1] == 'l')
        -: 1927:                {
        -: 1928:                    *length = 2;
        -: 1929:                    length_mod = UNITY_LENGTH_MODIFIER_LONG_LONG;
        -: 1930:                }
        -: 1931:                else
        -: 1932:                {
        -: 1933:                    *length = 1;
        -: 1934:                    length_mod = UNITY_LENGTH_MODIFIER_LONG;
        -: 1935:                }
        -: 1936:                break;
        -: 1937:            }
        -: 1938:        case 'h':
        -: 1939:            {
        -: 1940:                // short and char are converted to int
        -: 1941:                length_mod = UNITY_LENGTH_MODIFIER_NONE;
        -: 1942:                if (pch[1] == 'h')
        -: 1943:                {
        -: 1944:                    *length = 2;
        -: 1945:                }
        -: 1946:                else
        -: 1947:                {
        -: 1948:                    *length = 1;
        -: 1949:                }
        -: 1950:                break;
        -: 1951:            }
        -: 1952:        case 'j':
        -: 1953:        case 'z':
        -: 1954:        case 't':
        -: 1955:        case 'L':
        -: 1956:            {
        -: 1957:                // Not supported, but should gobble up the length specifier anyway
        -: 1958:                length_mod = UNITY_LENGTH_MODIFIER_NONE;
        -: 1959:                *length = 1;
        -: 1960:                break;
        -: 1961:            }
        -: 1962:        default:
        -: 1963:            {
        -: 1964:                length_mod = UNITY_LENGTH_MODIFIER_NONE;
        -: 1965:                *length = 0;
        -: 1966:            }
        -: 1967:    }
        -: 1968:    return length_mod;
        -: 1969:}
        -: 1970:
        -: 1971:/*-----------------------------------------------
        -: 1972: * printf helper function
        -: 1973: *-----------------------------------------------*/
        -: 1974:static void UnityPrintFVA(const char* format, va_list va)
        -: 1975:{
        -: 1976:    const char* pch = format;
        -: 1977:    if (pch != NULL)
        -: 1978:    {
        -: 1979:        while (*pch)
        -: 1980:        {
        -: 1981:            /* format identification character */
        -: 1982:            if (*pch == '%')
        -: 1983:            {
        -: 1984:                pch++;
        -: 1985:
        -: 1986:                if (pch != NULL)
        -: 1987:                {
        -: 1988:                    int length_mod_size;
        -: 1989:                    enum UnityLengthModifier length_mod = UnityLengthModifierGet(pch, &length_mod_size);
        -: 1990:                    pch += length_mod_size;
        -: 1991:
        -: 1992:                    switch (*pch)
        -: 1993:                    {
        -: 1994:                        case 'd':
        -: 1995:                        case 'i':
        -: 1996:                            {
        -: 1997:                                UNITY_INT number;
        -: 1998:                                UNITY_EXTRACT_ARG(UNITY_INT, number, length_mod, va, int);
        -: 1999:                                UnityPrintNumber((UNITY_INT)number);
        -: 2000:                                break;
        -: 2001:                            }
        -: 2002:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -: 2003:                        case 'f':
        -: 2004:                        case 'g':
        -: 2005:                            {
        -: 2006:                                const double number = va_arg(va, double);
        -: 2007:                                UnityPrintFloat((UNITY_DOUBLE)number);
        -: 2008:                                break;
        -: 2009:                            }
        -: 2010:#endif
        -: 2011:                        case 'u':
        -: 2012:                            {
        -: 2013:                                UNITY_UINT number;
        -: 2014:                                UNITY_EXTRACT_ARG(UNITY_UINT, number, length_mod, va, unsigned int);
        -: 2015:                                UnityPrintNumberUnsigned(number);
        -: 2016:                                break;
        -: 2017:                            }
        -: 2018:                        case 'b':
        -: 2019:                            {
        -: 2020:                                UNITY_UINT number;
        -: 2021:                                UNITY_EXTRACT_ARG(UNITY_UINT, number, length_mod, va, unsigned int);
        -: 2022:                                const UNITY_UINT mask = (UNITY_UINT)0 - (UNITY_UINT)1;
        -: 2023:                                UNITY_OUTPUT_CHAR('0');
        -: 2024:                                UNITY_OUTPUT_CHAR('b');
        -: 2025:                                UnityPrintMask(mask, number);
        -: 2026:                                break;
        -: 2027:                            }
        -: 2028:                        case 'x':
        -: 2029:                        case 'X':
        -: 2030:                            {
        -: 2031:                                UNITY_UINT number;
        -: 2032:                                UNITY_EXTRACT_ARG(UNITY_UINT, number, length_mod, va, unsigned int);
        -: 2033:                                UNITY_OUTPUT_CHAR('0');
        -: 2034:                                UNITY_OUTPUT_CHAR('x');
        -: 2035:                                UnityPrintNumberHex(number, UNITY_MAX_NIBBLES);
        -: 2036:                                break;
        -: 2037:                            }
        -: 2038:                        case 'p':
        -: 2039:                            {
        -: 2040:                                UNITY_UINT number;
        -: 2041:                                char nibbles_to_print = 8;
        -: 2042:                                if (UNITY_POINTER_WIDTH == 64)
        -: 2043:                                {
        -: 2044:                                    length_mod = UNITY_LENGTH_MODIFIER_LONG_LONG;
        -: 2045:                                    nibbles_to_print = 16;
        -: 2046:                                }
        -: 2047:                                UNITY_EXTRACT_ARG(UNITY_UINT, number, length_mod, va, unsigned int);
        -: 2048:                                UNITY_OUTPUT_CHAR('0');
        -: 2049:                                UNITY_OUTPUT_CHAR('x');
        -: 2050:                                UnityPrintNumberHex((UNITY_UINT)number, nibbles_to_print);
        -: 2051:                                break;
        -: 2052:                            }
        -: 2053:                        case 'c':
        -: 2054:                            {
        -: 2055:                                const int ch = va_arg(va, int);
        -: 2056:                                UnityPrintChar((const char *)&ch);
        -: 2057:                                break;
        -: 2058:                            }
        -: 2059:                        case 's':
        -: 2060:                            {
        -: 2061:                                const char * string = va_arg(va, const char *);
        -: 2062:                                UnityPrint(string);
        -: 2063:                                break;
        -: 2064:                            }
        -: 2065:                        case '%':
        -: 2066:                            {
        -: 2067:                                UnityPrintChar(pch);
        -: 2068:                                break;
        -: 2069:                            }
        -: 2070:                        default:
        -: 2071:                            {
        -: 2072:                                /* print the unknown format character */
        -: 2073:                                UNITY_OUTPUT_CHAR('%');
        -: 2074:                                UnityPrintChar(pch);
        -: 2075:                                break;
        -: 2076:                            }
        -: 2077:                    }
        -: 2078:                }
        -: 2079:            }
        -: 2080:#ifdef UNITY_OUTPUT_COLOR
        -: 2081:            /* print ANSI escape code */
        -: 2082:            else if ((*pch == 27) && (*(pch + 1) == '['))
        -: 2083:            {
        -: 2084:                pch += UnityPrintAnsiEscapeString(pch);
        -: 2085:                continue;
        -: 2086:            }
        -: 2087:#endif
        -: 2088:            else if (*pch == '\n')
        -: 2089:            {
        -: 2090:                UNITY_PRINT_EOL();
        -: 2091:            }
        -: 2092:            else
        -: 2093:            {
        -: 2094:                UnityPrintChar(pch);
        -: 2095:            }
        -: 2096:
        -: 2097:            pch++;
        -: 2098:        }
        -: 2099:    }
        -: 2100:}
        -: 2101:
        -: 2102:void UnityPrintF(const UNITY_LINE_TYPE line, const char* format, ...)
        -: 2103:{
        -: 2104:    UnityTestResultsBegin(Unity.TestFile, line);
        -: 2105:    UnityPrint("INFO");
        -: 2106:    if(format != NULL)
        -: 2107:    {
        -: 2108:        UnityPrint(": ");
        -: 2109:        va_list va;
        -: 2110:        va_start(va, format);
        -: 2111:        UnityPrintFVA(format, va);
        -: 2112:        va_end(va);
        -: 2113:    }
        -: 2114:    UNITY_PRINT_EOL();
        -: 2115:}
        -: 2116:#endif /* ! UNITY_INCLUDE_PRINT_FORMATTED */
        -: 2117:
        -: 2118:
        -: 2119:/*-----------------------------------------------
        -: 2120: * Control Functions
        -: 2121: *-----------------------------------------------*/
        -: 2122:
        -: 2123:/*-----------------------------------------------*/
    #####: 2124:void UnityFail(const char* msg, const UNITY_LINE_TYPE line)
        -: 2125:{
    #####: 2126:    RETURN_IF_FAIL_OR_IGNORE;
        -: 2127:
    #####: 2128:    UnityTestResultsBegin(Unity.TestFile, line);
    #####: 2129:    UnityPrint(UnityStrFail);
    #####: 2130:    if (msg != NULL)
        -: 2131:    {
    #####: 2132:        UNITY_OUTPUT_CHAR(':');
        -: 2133:
        -: 2134:#ifdef UNITY_PRINT_TEST_CONTEXT
        -: 2135:        UNITY_PRINT_TEST_CONTEXT();
        -: 2136:#endif
        -: 2137:#ifndef UNITY_EXCLUDE_DETAILS
    #####: 2138:        if (Unity.CurrentDetail1)
        -: 2139:        {
    #####: 2140:            UnityPrint(UnityStrDetail1Name);
    #####: 2141:            UnityPrint(Unity.CurrentDetail1);
    #####: 2142:            if (Unity.CurrentDetail2)
        -: 2143:            {
    #####: 2144:                UnityPrint(UnityStrDetail2Name);
    #####: 2145:                UnityPrint(Unity.CurrentDetail2);
        -: 2146:            }
    #####: 2147:            UnityPrint(UnityStrSpacer);
        -: 2148:        }
        -: 2149:#endif
    #####: 2150:        if (msg[0] != ' ')
        -: 2151:        {
    #####: 2152:            UNITY_OUTPUT_CHAR(' ');
        -: 2153:        }
    #####: 2154:        UnityPrint(msg);
        -: 2155:    }
        -: 2156:
    #####: 2157:    UNITY_FAIL_AND_BAIL;
        -: 2158:}
        -: 2159:
        -: 2160:/*-----------------------------------------------*/
    #####: 2161:void UnityIgnore(const char* msg, const UNITY_LINE_TYPE line)
        -: 2162:{
    #####: 2163:    RETURN_IF_FAIL_OR_IGNORE;
        -: 2164:
    #####: 2165:    UnityTestResultsBegin(Unity.TestFile, line);
    #####: 2166:    UnityPrint(UnityStrIgnore);
    #####: 2167:    if (msg != NULL)
        -: 2168:    {
    #####: 2169:        UNITY_OUTPUT_CHAR(':');
    #####: 2170:        UNITY_OUTPUT_CHAR(' ');
    #####: 2171:        UnityPrint(msg);
        -: 2172:    }
    #####: 2173:    UNITY_IGNORE_AND_BAIL;
        -: 2174:}
        -: 2175:
        -: 2176:/*-----------------------------------------------*/
    #####: 2177:void UnityMessage(const char* msg, const UNITY_LINE_TYPE line)
        -: 2178:{
    #####: 2179:    UnityTestResultsBegin(Unity.TestFile, line);
    #####: 2180:    UnityPrint("INFO");
    #####: 2181:    if (msg != NULL)
        -: 2182:    {
    #####: 2183:      UNITY_OUTPUT_CHAR(':');
    #####: 2184:      UNITY_OUTPUT_CHAR(' ');
    #####: 2185:      UnityPrint(msg);
        -: 2186:    }
    #####: 2187:    UNITY_PRINT_EOL();
    #####: 2188:}
        -: 2189:
        -: 2190:/*-----------------------------------------------*/
        -: 2191:/* If we have not defined our own test runner, then include our default test runner to make life easier */
        -: 2192:#ifndef UNITY_SKIP_DEFAULT_RUNNER
        4: 2193:void UnityDefaultTestRun(UnityTestFunction Func, const char* FuncName, const int FuncLineNum)
        -: 2194:{
        4: 2195:    Unity.CurrentTestName = FuncName;
        4: 2196:    Unity.CurrentTestLineNumber = (UNITY_LINE_TYPE)FuncLineNum;
        4: 2197:    Unity.NumberOfTests++;
        4: 2198:    UNITY_CLR_DETAILS();
        -: 2199:    UNITY_EXEC_TIME_START();
        4: 2200:    if (TEST_PROTECT())
        -: 2201:    {
        4: 2202:        setUp();
        4: 2203:        Func();
        -: 2204:    }
        4: 2205:    if (TEST_PROTECT())
        -: 2206:    {
        4: 2207:        tearDown();
        -: 2208:    }
        -: 2209:    UNITY_EXEC_TIME_STOP();
        4: 2210:    UnityConcludeTest();
        4: 2211:}
        -: 2212:#endif
        -: 2213:
        -: 2214:/*-----------------------------------------------*/
    #####: 2215:void UnitySetTestFile(const char* filename)
        -: 2216:{
    #####: 2217:    Unity.TestFile = filename;
    #####: 2218:}
        -: 2219:
        -: 2220:/*-----------------------------------------------*/
        2: 2221:void UnityBegin(const char* filename)
        -: 2222:{
        2: 2223:    Unity.TestFile = filename;
        2: 2224:    Unity.CurrentTestName = NULL;
        2: 2225:    Unity.CurrentTestLineNumber = 0;
        2: 2226:    Unity.NumberOfTests = 0;
        2: 2227:    Unity.TestFailures = 0;
        2: 2228:    Unity.TestIgnores = 0;
        2: 2229:    Unity.CurrentTestFailed = 0;
        2: 2230:    Unity.CurrentTestIgnored = 0;
        -: 2231:
        2: 2232:    UNITY_CLR_DETAILS();
        2: 2233:    UNITY_OUTPUT_START();
        2: 2234:}
        -: 2235:
        -: 2236:/*-----------------------------------------------*/
        2: 2237:int UnityEnd(void)
        -: 2238:{
        2: 2239:    UNITY_PRINT_EOL();
        2: 2240:    UnityPrint(UnityStrBreaker);
        2: 2241:    UNITY_PRINT_EOL();
        2: 2242:    UnityPrintNumber((UNITY_INT)(Unity.NumberOfTests));
        2: 2243:    UnityPrint(UnityStrResultsTests);
        2: 2244:    UnityPrintNumber((UNITY_INT)(Unity.TestFailures));
        2: 2245:    UnityPrint(UnityStrResultsFailures);
        2: 2246:    UnityPrintNumber((UNITY_INT)(Unity.TestIgnores));
        2: 2247:    UnityPrint(UnityStrResultsIgnored);
        2: 2248:    UNITY_PRINT_EOL();
        2: 2249:    if (Unity.TestFailures == 0U)
        -: 2250:    {
        2: 2251:        UnityPrint(UnityStrOk);
        -: 2252:    }
        -: 2253:    else
        -: 2254:    {
    #####: 2255:        UnityPrint(UnityStrFail);
        -: 2256:#ifdef UNITY_DIFFERENTIATE_FINAL_FAIL
        -: 2257:        UNITY_OUTPUT_CHAR('E'); UNITY_OUTPUT_CHAR('D');
        -: 2258:#endif
        -: 2259:    }
        2: 2260:    UNITY_PRINT_EOL();
        2: 2261:    UNITY_FLUSH_CALL();
        2: 2262:    UNITY_OUTPUT_COMPLETE();
        2: 2263:    return (int)(Unity.TestFailures);
        -: 2264:}
        -: 2265:
        -: 2266:/*-----------------------------------------------
        -: 2267: * Command Line Argument Support
        -: 2268: *-----------------------------------------------*/
        -: 2269:#ifdef UNITY_USE_COMMAND_LINE_ARGS
        -: 2270:
        -: 2271:char* UnityOptionIncludeNamed = NULL;
        -: 2272:char* UnityOptionExcludeNamed = NULL;
        -: 2273:int UnityVerbosity            = 1;
        -: 2274:int UnityStrictMatch          = 0;
        -: 2275:
        -: 2276:/*-----------------------------------------------*/
        -: 2277:int UnityParseOptions(int argc, char** argv)
        -: 2278:{
        -: 2279:    int i;
        -: 2280:    UnityOptionIncludeNamed = NULL;
        -: 2281:    UnityOptionExcludeNamed = NULL;
        -: 2282:    UnityStrictMatch = 0;
        -: 2283:
        -: 2284:    for (i = 1; i < argc; i++)
        -: 2285:    {
        -: 2286:        if (argv[i][0] == '-')
        -: 2287:        {
        -: 2288:            switch (argv[i][1])
        -: 2289:            {
        -: 2290:                case 'l': /* list tests */
        -: 2291:                    return -1;
        -: 2292:                case 'n': /* include tests with name including this string */
        -: 2293:                case 'f': /* an alias for -n */
        -: 2294:                    UnityStrictMatch = (argv[i][1] == 'n'); /* strictly match this string if -n */
        -: 2295:                    if (argv[i][2] == '=')
        -: 2296:                    {
        -: 2297:                        UnityOptionIncludeNamed = &argv[i][3];
        -: 2298:                    }
        -: 2299:                    else if (++i < argc)
        -: 2300:                    {
        -: 2301:                        UnityOptionIncludeNamed = argv[i];
        -: 2302:                    }
        -: 2303:                    else
        -: 2304:                    {
        -: 2305:                        UnityPrint("ERROR: No Test String to Include Matches For");
        -: 2306:                        UNITY_PRINT_EOL();
        -: 2307:                        return 1;
        -: 2308:                    }
        -: 2309:                    break;
        -: 2310:                case 'q': /* quiet */
        -: 2311:                    UnityVerbosity = 0;
        -: 2312:                    break;
        -: 2313:                case 'v': /* verbose */
        -: 2314:                    UnityVerbosity = 2;
        -: 2315:                    break;
        -: 2316:                case 'x': /* exclude tests with name including this string */
        -: 2317:                    if (argv[i][2] == '=')
        -: 2318:                    {
        -: 2319:                        UnityOptionExcludeNamed = &argv[i][3];
        -: 2320:                    }
        -: 2321:                    else if (++i < argc)
        -: 2322:                    {
        -: 2323:                        UnityOptionExcludeNamed = argv[i];
        -: 2324:                    }
        -: 2325:                    else
        -: 2326:                    {
        -: 2327:                        UnityPrint("ERROR: No Test String to Exclude Matches For");
        -: 2328:                        UNITY_PRINT_EOL();
        -: 2329:                        return 1;
        -: 2330:                    }
        -: 2331:                    break;
        -: 2332:                default:
        -: 2333:                    UnityPrint("ERROR: Unknown Option ");
        -: 2334:                    UNITY_OUTPUT_CHAR(argv[i][1]);
        -: 2335:                    UNITY_PRINT_EOL();
        -: 2336:                    /* Now display help */
        -: 2337:                    /* FALLTHRU */
        -: 2338:                case 'h':
        -: 2339:                    UnityPrint("Options: "); UNITY_PRINT_EOL();
        -: 2340:                    UnityPrint("-l        List all tests and exit"); UNITY_PRINT_EOL();
        -: 2341:                    UnityPrint("-f NAME   Filter to run only tests whose name includes NAME"); UNITY_PRINT_EOL();
        -: 2342:                    UnityPrint("-n NAME   Run only the test named NAME"); UNITY_PRINT_EOL();
        -: 2343:                    UnityPrint("-h        show this Help menu"); UNITY_PRINT_EOL();
        -: 2344:                    UnityPrint("-q        Quiet/decrease verbosity"); UNITY_PRINT_EOL();
        -: 2345:                    UnityPrint("-v        increase Verbosity"); UNITY_PRINT_EOL();
        -: 2346:                    UnityPrint("-x NAME   eXclude tests whose name includes NAME"); UNITY_PRINT_EOL();
        -: 2347:                    UNITY_OUTPUT_FLUSH();
        -: 2348:                    return 1;
        -: 2349:            }
        -: 2350:        }
        -: 2351:    }
        -: 2352:
        -: 2353:    return 0;
        -: 2354:}
        -: 2355:
        -: 2356:/*-----------------------------------------------*/
        -: 2357:static int IsStringInBiggerString(const char* longstring, const char* shortstring)
        -: 2358:{
        -: 2359:    const char* lptr = longstring;
        -: 2360:    const char* sptr = shortstring;
        -: 2361:    const char* lnext = lptr;
        -: 2362:
        -: 2363:    if (*sptr == '*')
        -: 2364:    {
        -: 2365:        return UnityStrictMatch ? 0 : 1;
        -: 2366:    }
        -: 2367:
        -: 2368:    while (*lptr)
        -: 2369:    {
        -: 2370:        lnext = lptr + 1;
        -: 2371:
        -: 2372:        /* If they current bytes match, go on to the next bytes */
        -: 2373:        while (*lptr && *sptr && (*lptr == *sptr))
        -: 2374:        {
        -: 2375:            lptr++;
        -: 2376:            sptr++;
        -: 2377:
        -: 2378:            switch (*sptr)
        -: 2379:            {
        -: 2380:                case '*': /* we encountered a wild-card */
        -: 2381:                    return UnityStrictMatch ? 0 : 1;
        -: 2382:
        -: 2383:                case ',': /* we encountered the end of match string */
        -: 2384:                case '"':
        -: 2385:                case '\'':
        -: 2386:                case 0:
        -: 2387:                    return (!UnityStrictMatch || (*lptr == 0)) ? 1 : 0;
        -: 2388:
        -: 2389:                case ':': /* we encountered the end of a partial match */
        -: 2390:                    return 2;
        -: 2391:
        -: 2392:                default:
        -: 2393:                    break;
        -: 2394:            }
        -: 2395:        }
        -: 2396:
        -: 2397:        // If we didn't match and we're on strict matching, we already know we failed
        -: 2398:        if (UnityStrictMatch)
        -: 2399:        {
        -: 2400:            return 0;
        -: 2401:        }
        -: 2402:
        -: 2403:        /* Otherwise we start in the long pointer 1 character further and try again */
        -: 2404:        lptr = lnext;
        -: 2405:        sptr = shortstring;
        -: 2406:    }
        -: 2407:
        -: 2408:    return 0;
        -: 2409:}
        -: 2410:
        -: 2411:/*-----------------------------------------------*/
        -: 2412:static int UnityStringArgumentMatches(const char* str)
        -: 2413:{
        -: 2414:    int retval;
        -: 2415:    const char* ptr1;
        -: 2416:    const char* ptr2;
        -: 2417:    const char* ptrf;
        -: 2418:
        -: 2419:    /* Go through the options and get the substrings for matching one at a time */
        -: 2420:    ptr1 = str;
        -: 2421:    while (ptr1[0] != 0)
        -: 2422:    {
        -: 2423:        if ((ptr1[0] == '"') || (ptr1[0] == '\''))
        -: 2424:        {
        -: 2425:            ptr1++;
        -: 2426:        }
        -: 2427:
        -: 2428:        /* look for the start of the next partial */
        -: 2429:        ptr2 = ptr1;
        -: 2430:        ptrf = 0;
        -: 2431:        do
        -: 2432:        {
        -: 2433:            ptr2++;
        -: 2434:            if ((ptr2[0] == ':') && (ptr2[1] != 0) && (ptr2[0] != '\'') && (ptr2[0] != '"') && (ptr2[0] != ','))
        -: 2435:            {
        -: 2436:                ptrf = &ptr2[1];
        -: 2437:            }
        -: 2438:        } while ((ptr2[0] != 0) && (ptr2[0] != '\'') && (ptr2[0] != '"') && (ptr2[0] != ','));
        -: 2439:
        -: 2440:        while ((ptr2[0] != 0) && ((ptr2[0] == ':') || (ptr2[0] == '\'') || (ptr2[0] == '"') || (ptr2[0] == ',')))
        -: 2441:        {
        -: 2442:            ptr2++;
        -: 2443:        }
        -: 2444:
        -: 2445:        /* done if complete filename match */
        -: 2446:        retval = IsStringInBiggerString(Unity.TestFile, ptr1);
        -: 2447:        if (retval == 1)
        -: 2448:        {
        -: 2449:            return retval;
        -: 2450:        }
        -: 2451:
        -: 2452:        /* done if testname match after filename partial match */
        -: 2453:        if ((retval == 2) && (ptrf != 0))
        -: 2454:        {
        -: 2455:            if (IsStringInBiggerString(Unity.CurrentTestName, ptrf))
        -: 2456:            {
        -: 2457:                return 1;
        -: 2458:            }
        -: 2459:        }
        -: 2460:
        -: 2461:        /* done if complete testname match */
        -: 2462:        if (IsStringInBiggerString(Unity.CurrentTestName, ptr1) == 1)
        -: 2463:        {
        -: 2464:            return 1;
        -: 2465:        }
        -: 2466:
        -: 2467:        ptr1 = ptr2;
        -: 2468:    }
        -: 2469:
        -: 2470:    /* we couldn't find a match for any substrings */
        -: 2471:    return 0;
        -: 2472:}
        -: 2473:
        -: 2474:/*-----------------------------------------------*/
        -: 2475:int UnityTestMatches(void)
        -: 2476:{
        -: 2477:    /* Check if this test name matches the included test pattern */
        -: 2478:    int retval;
        -: 2479:    if (UnityOptionIncludeNamed)
        -: 2480:    {
        -: 2481:        retval = UnityStringArgumentMatches(UnityOptionIncludeNamed);
        -: 2482:    }
        -: 2483:    else
        -: 2484:    {
        -: 2485:        retval = 1;
        -: 2486:    }
        -: 2487:
        -: 2488:    /* Check if this test name matches the excluded test pattern */
        -: 2489:    if (UnityOptionExcludeNamed)
        -: 2490:    {
        -: 2491:        if (UnityStringArgumentMatches(UnityOptionExcludeNamed))
        -: 2492:        {
        -: 2493:            retval = 0;
        -: 2494:        }
        -: 2495:    }
        -: 2496:
        -: 2497:    return retval;
        -: 2498:}
        -: 2499:
        -: 2500:#endif /* UNITY_USE_COMMAND_LINE_ARGS */
        -: 2501:/*-----------------------------------------------*/
